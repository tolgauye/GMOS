//======================================================================================
//======================================================================================
// Filename: PSP103_module.include
//======================================================================================
//======================================================================================
//
//  (c) Copyright notice
//
//  Since 2015 until today, PSP has been co-developed by NXP Semiconductors and
//  CEA-Leti. For this part of the model, each claim undivided ownership and copyrights
//  Since 2012 until 2015, PSP has been co-developed by NXP Semiconductors and
//  Delft University of Technology. For this part of the model, each claim undivided
//  ownership and copyrights
//  Until and including 2011, PSP has been co-developed by NXP Semiconductors and
//  Arizona State University. For this part of the model, NXP Semiconductors claims
//  undivided ownership and copyrights.
//
//
//  Version: 103.7.0 (PSP), 200.6.0 (JUNCAP), April 2019
//
//======================================================================================
//======================================================================================
//
// Further information can be found in the file releasenotesPSP103.txt
//
//  --------------------------------------------------------------------------------------------------------------
//  Node definitions
//  --------------------------------------------------------------------------------------------------------------

`ifdef SelfHeating
    inout      D, G, S, B, DT;
`else // SelfHeating
    inout      D, G, S, B;
`endif // SelfHeating
electrical D;
electrical G;
electrical S;
electrical B;
`ifdef SelfHeating
    thermal DT;
    branch     (DT) br_rth, br_ith;
`endif // SelfHeating

// Internal nodes and branches for correlated drain and gate noise
electrical NOI;
branch (NOI) NOII;
branch (NOI) NOIR;
branch (NOI) NOIC;

// Internal nodes for gate and bulk resistors
electrical GP;
electrical SI;
electrical DI;
electrical BP;
electrical BI;
electrical BS;
electrical BD;

// Internal nodes and branches for spline collocation (NQS)
`ifdef NQSmodel
    electrical INT1;
    electrical INT2;
    electrical INT3;
    electrical INT4;
    electrical INT5;
    electrical INT6;
    electrical INT7;
    electrical INT8;
    electrical INT9;
    branch(INT1) SPLINE1;
    branch(INT2) SPLINE2;
    branch(INT3) SPLINE3;
    branch(INT4) SPLINE4;
    branch(INT5) SPLINE5;
    branch(INT6) SPLINE6;
    branch(INT7) SPLINE7;
    branch(INT8) SPLINE8;
    branch(INT9) SPLINE9;
    branch(INT1) RES1;
    branch(INT2) RES2;
    branch(INT3) RES3;
    branch(INT4) RES4;
    branch(INT5) RES5;
    branch(INT6) RES6;
    branch(INT7) RES7;
    branch(INT8) RES8;
    branch(INT9) RES9;
`endif // NQSmodel



//  --------------------------------------------------------------------------------------------------------------
//  Instance parameters
//  --------------------------------------------------------------------------------------------------------------

// Instance parameters for global and binning models only
`IPRco(L              ,1.0e-5     ,"m"        ,1.0e-9      ,inf         ,"Design length")
`IPRco(W              ,1.0e-5     ,"m"        ,1.0e-9      ,inf         ,"Design width")
`IPRnb(SA             ,0.0        ,"m"                                  ,"Distance between OD-edge and poly from one side")
`IPRnb(SB             ,0.0        ,"m"                                  ,"Distance between OD-edge and poly from other side")
`IPRnb(SD             ,0.0        ,"m"                                  ,"Distance between neighbouring fingers")
`IPRcz(SCA            ,0.0        ,""                                   ,"Integral of the first distribution function for scattered well dopants")
`IPRcz(SCB            ,0.0        ,""                                   ,"Integral of the second distribution function for scattered well dopants")
`IPRcz(SCC            ,0.0        ,""                                   ,"Integral of the third distribution function for scattered well dopants")
`IPRnb(SC             ,0.0        ,"m"                                  ,"Distance between OD-edge and nearest well edge")
`IPRco(NF             ,1.0        ,""         ,1.0         ,inf         ,"Number of fingers")
`IPRcc(NGCON          ,1.0        ,""         ,1.0         ,2.0         ,"Number of gate contacts")
`IPRnb(XGW            ,1.0e-7     ,"m"                                  ,"Distance from the gate contact to the channel edge")
`IPRnb(NRS            ,0.0        ,""                                   ,"Number of squares of source diffusion")
`IPRnb(NRD            ,0.0        ,""                                   ,"Number of squares of drain diffusion")

// Instance parameters for local model only
`IPRco(JW             ,1.0e-6     ,"m"        ,`LG_cliplow ,inf         ,"Gate-edge length of source/drain junction")

// Instance parameters for global, binning, and local models
`IPRnb(DELVTO         ,0.0        ,"V"                                  ,"Threshold voltage shift parameter")
`IPRcz(FACTUO         ,1.0        ,""                                   ,"Zero-field mobility pre-factor")
`IPRnb(DELVTOEDGE     ,0.0        ,"V"                                  ,"Threshold voltage shift parameter of edge transistor")
`IPRcz(FACTUOEDGE     ,1.0        ,""                                   ,"Zero-field mobility pre-factor of edge transistor")
`IPRco(ABSOURCE       ,1.0e-12    ,"m^2"      ,`AB_cliplow ,inf         ,"Bottom area of source junction")
`IPRco(LSSOURCE       ,1.0e-6     ,"m"        ,`LS_cliplow ,inf         ,"STI-edge length of source junction")
`IPRco(LGSOURCE       ,1.0e-6     ,"m"        ,`LG_cliplow ,inf         ,"Gate-edge length of source junction")
`IPRco(ABDRAIN        ,1.0e-12    ,"m^2"      ,`AB_cliplow ,inf         ,"Bottom area of drain junction")
`IPRco(LSDRAIN        ,1.0e-6     ,"m"        ,`LS_cliplow ,inf         ,"STI-edge length of drain junction")
`IPRco(LGDRAIN        ,1.0e-6     ,"m"        ,`LG_cliplow ,inf         ,"Gate-edge length of drain junction")
`IPRco(AS             ,1.0e-12    ,"m^2"      ,`AB_cliplow ,inf         ,"Bottom area of source junction")
`IPRco(PS             ,1.0e-6     ,"m"        ,`LS_cliplow ,inf         ,"Perimeter of source junction")
`IPRco(AD             ,1.0e-12    ,"m^2"      ,`AB_cliplow ,inf         ,"Bottom area of drain junction")
`IPRco(PD             ,1.0e-6     ,"m"        ,`LS_cliplow ,inf         ,"Perimeter of drain junction")
`IPRco(MULT           ,1.0        ,""         ,0.0         ,inf         ,"Number of devices in parallel")

//  --------------------------------------------------------------------------------------------------------------
//  PSP Model Parameters
//  --------------------------------------------------------------------------------------------------------------
`include "PSP103_parlist.include"

//  --------------------------------------------------------------------------------------------------------------
//  JUNCAP Model Parameters
//  --------------------------------------------------------------------------------------------------------------
`include "JUNCAP200_parlist.include"

//  --------------------------------------------------------------------------------------------------------------
//  Variables
//  --------------------------------------------------------------------------------------------------------------

// Variables for switch (initial_model parts)
integer CHNL_TYPE, SWGEO_i, SWIGATE_i, SWIMPACT_i, SWGIDL_i, SWJUNCAP_i, SWJUNASYM_i, SWNUD_i, SWEDGE_i, SWDELVTAC_i;
integer SWQSAT_i, SWQPART_i, SWIGN_i;

// Instance local variables
real NF_i, invNF, L_i, W_i, SA_i, SB_i, SD_i, SC_i, XGW_i, JW_i, SCA_i, SCB_i, SCC_i, NGCON_i, MULT_i, FACTUO_i, DELVTO_i;
real FACTUOEDGE_i, DELVTOEDGE_i;

// Instance local variables for juncap
real ABS_i, LSS_i, LGS_i, ABD_i, LSD_i, LGD_i, jwcorr, jww;

// Variables of clipped global model parameters
real TOXO_i, EPSROXO_i, NSUBO_i, WSEG_i, NPCK_i, WSEGP_i, LPCK_i, TOXOVO_i, TOXOVDO_i, LOV_i, LOVD_i, LP1_i, LP2_i, WBET_i;
real AXL_i, ALP1L2_i, ALP2L2_i, SAREF_i, SBREF_i, KVSAT_i, LLODKUO_i, WLODKUO_i, LLODVTH_i, WLODVTH_i, LODETAO_i, SCREF_i;
real WEB_i, WEC_i, RSHG_i, RSH_i, RSHD_i, RINT_i, RVPOLY_i, NSUBEDGEO_i, LPEDGE_i;

// Variables of internal global-binning parameters of charge model
real CFACL_i, CFACW_i, CFACLEXP_i, THESATACO_i, THESATACL_i, THESATACLEXP_i, THESATACW_i, THESATACLW_i, AXACO_i, AXACL_i, ALPACL_i;
real ALPACLEXP_i, ALPACW_i, POCFAC_i, PLCFAC_i, PWCFAC_i, PLWCFAC_i, POTHESATAC_i, PLTHESATAC_i, PWTHESATAC_i, PLWTHESATAC_i;
real POAXAC_i, PLAXAC_i, PWAXAC_i, PLWAXAC_i, POALPAC_i, PLALPAC_i, PWALPAC_i, PLWALPAC_i, KVSATAC_i;

// Variables of local model parameters
real VFB_p, STVFB_p, ST2VFB_p, TOX_p, EPSROX_p, NEFF_p, FACNEFFAC_p, GFACNUD_p, VSBNUD_p, DVSBNUD_p, VNSUB_p, NSLP_p, DNSUB_p;
real DPHIB_p, DELVTAC_p, NP_p, CT_p, CTG_p, CTB_p, STCT_p, TOXOV_p, TOXOVD_p, NOV_p, NOVD_p, PSCE_p, PSCED_p, PSCEB_p, CF_p, CFAC_p;
real CFD_p, CFB_p, BETN_p, STBET_p, MUE_p, STMUE_p, THEMU_p, STTHEMU_p, CS_p, STCS_p, THECS_p, STTHECS_p, XCOR_p, STXCOR_p;
real FETA_p, RS_p, STRS_p, RSB_p, RSG_p, THESAT_p, THESATAC_p, STTHESAT_p, THESATB_p, THESATG_p, AX_p, AXAC_p, ALP_p, ALPAC_p;
real ALP1_p, ALP2_p, VP_p, A1_p, A2_p, STA2_p, A3_p, A4_p, GCO_p, IGINV_p, IGOV_p, IGOVD_p, STIG_p, GC2_p, GC3_p, GC2OV_p, GC3OV_p;
real CHIB_p, AGIDL_p, AGIDLD_p, BGIDL_p, BGIDLD_p, STBGIDL_p, STBGIDLD_p, CGIDL_p, CGIDLD_p, COX_p, CGOV_p, CGOVD_p, CGBOV_p, CFR_p;
real CFRD_p, FNT_p, FNTEXC_p, NFA_p, NFB_p, NFC_p, EF_p, VFBEDGE_p, STVFBEDGE_p, DPHIBEDGE_p, NEFFEDGE_p, CTEDGE_p, BETNEDGE_p;
real STBETEDGE_p, PSCEEDGE_p, PSCEBEDGE_p, PSCEDEDGE_p, CFEDGE_p, CFDEDGE_p, CFBEDGE_p, FNTEDGE_p, NFAEDGE_p, NFBEDGE_p, NFCEDGE_p;
real EFEDGE_p, RG_p, RSE_p, RDE_p, RWELL_p, RBULK_p, RJUNS_p, RJUND_p;
`ifdef SelfHeating
    real RTH_p, CTH_p, STRTH_p;
`endif // SelfHeating
`ifdef NQSmodel
    real MUNQS_p;
`endif // NQSmodel

// Variables of clipped local model parameters
real TR_i, QMC_i, VFB_i, STVFB_i, ST2VFB_i, STCT_i, TOX_i, EPSROX_i, NEFF_i, FACNEFFAC_i, GFACNUD_i, VSBNUD_i, DVSBNUD_i, VNSUB_i, NSLP_i;
real DNSUB_i, DPHIB_i, DELVTAC_i, NP_i, CT_i, CTG_i, CTB_i, TOXOV_i, TOXOVD_i, NOV_i, NOVD_i, CF_i, CFAC_i, CFD_i, CFB_i, PSCE_i, PSCEB_i;
real PSCED_i, BETN_i, STBET_i, MUE_i, STMUE_i, THEMU_i, STTHEMU_i, CS_i, STCS_i, THECS_i, STTHECS_i, XCOR_i, STXCOR_i, FETA_i, RS_i, STRS_i;
real RSB_i, RSG_i, THESAT_i, THESATAC_i, STTHESAT_i, THESATB_i, THESATG_i, AX_i, AXAC_i, ALP_i, ALPAC_i, ALP1_i, ALP2_i, VP_i, A1_i, A2_i;
real STA2_i, A3_i, A4_i, GCO_i, IGINV_i, IGOV_i, IGOVD_i, STIG_i, GC2_i, GC3_i, GC2OV_i, GC3OV_i, CHIB_i, AGIDL_i, AGIDLD_i, BGIDL_i;
real BGIDLD_i, STBGIDL_i, STBGIDLD_i, CGIDL_i, CGIDLD_i, COX_i, CGOV_i, CGOVD_i, CGBOV_i, CFR_i, CFRD_i, FNT_i, FNTEXC_i, NFA_i, NFB_i;
real NFC_i, EF_i, VFBEDGE_i, STVFBEDGE_i, DPHIBEDGE_i, NEFFEDGE_i, CTEDGE_i, BETNEDGE_i, STBETEDGE_i, PSCEEDGE_i, PSCEBEDGE_i, PSCEDEDGE_i;
real CFEDGE_i, CFDEDGE_i, CFBEDGE_i, FNTEDGE_i, NFAEDGE_i, NFBEDGE_i, NFCEDGE_i, EFEDGE_i, RG_i, RSE_i, RDE_i, RBULK_i, RJUNS_i, RJUND_i;
real RWELL_i;
`ifdef SelfHeating
    real RTH_i, CTH_i, STRTH_i;
`endif // SelfHeating
`ifdef NQSmodel
    real MUNQS_i;
`endif // NQSmodel

// Variables for scaling rules
real iL, iW, delLPS, delWOD, LE, WE, LEcv, WEcv, Lcv, Wcv, iLE, iWE, L_f, L_slif, W_f, XGWE, NSUB0e, NPCKe, LPCKe, AA, BB, NSUB;
real FBET1e, LP1e, GPE, GWE, tmpx, Lnoi, Lred, WE_edge, iWE_edge, GPE_edge, KVTHOWE, KUOWE;
`ifdef SelfHeating
    real deltaRth;
`endif // SelfHeating

// Variables for binning-rules
real iLEWE, iiLE, iiWE, iiLEWE, iiiLEWE, iLEcv, iiLEcv, iiWEcv, iiLEWEcv, iiiLEWEcv, iLcv, iiLcv, iiWcv, iiLWcv, iiiLWcv;

// Variables for general temperature scaling
real TKR, TKA, rTa, delTa, phita, inv_phita, TKD, TKD_sq, delT, rTn, ln_rTn, inv_phit, Eg, phibFac;

// JUNCAP2 variables
`include "JUNCAP200_varlist.include"

// Local parameters after temperature scaling and variables used in self heating effect
real VFB_T, CT_T, CTG_T, BETN_T, MUE_T, THEMU_T, CS_T, THECS_T, XCOR_T, RS_T, BGIDL_T, BGIDLD_T, A2_T, VFBEDGE_T, BETNEDGE_T;
`ifdef SelfHeating
    real RTH_T;
`else // SelfHeating
    // in the self heating model, these variables are declared locally in the evaluate block
    real phit, BET_i, BETEDGE_i, nt0, nt, THESAT_T, THESATAC_T, Sfl_prefac, phit0edge, Gfedge2, lnGfedge2, Sfl_prefac_edge;
    real ntedge;
`endif // SelfHeating

// Variables for channel temperature scaling (including self heating effect)
real phib_dc, G_0_dc, kp, np, arg2max, qlim2, qb0, dphibq, sqrt_phib_dc, phix_dc, aphi_dc, bphi_dc, phix2, phix1_dc, alpha_b;
real us1, us21, phib_ac, G_0_ac, phix_ac, aphi_ac, bphi_ac, phix1_ac, tf_ct, tf_bet, tf_mue, tf_cs, tf_xcor, tf_ther, THER_i, tf_thesat;
real tf_betedge, phibedge, Gfedge, phixedge, aphiedge, bphiedge, phix2edge, phix1edge;

// Variables used in instance initializing
real EPSSI, EPSOX, CoxPrime, tox_sq, Cox_over_q, NEFFAC_i, qq, E_eff0, eta_mu, eta_mu1, inv_AX, inv_VP, CoxovPrime, CoxovPrime_d, GOV_s;
real GOV_d, GOV2_s, GOV2_d, SP_OV_eps2_s, SP_OV_a_s, SP_OV_delta1_s, SP_OV_eps2_d, SP_OV_a_d, SP_OV_delta1_d, inv_CHIB, B_fact, BCH;
real BOV, BOV_d, GCQ, GCQOV, tf_ig, AGIDLs, AGIDLDs, BGIDLs, BGIDLDs, fac_exc, ggate, gsource, gdrain, gbulk, gjuns, gjund, gwell;

// Variables for bias affectation
real Vgs, Vds, Vsb, Vdb, Vgb, Vjun_s, Vjun_d, VgsPrime, VsbPrime, VdbPrime, VgdPrime;
real Vdsx;

// Global variables used in PSP103_SPCalculation.include
real Vgb1, Vdsp, delVg, Vdsat_lim, Vdsat;

// Global variables used in current and charge calculations
real xgs_ov, xgd_ov, Vsbstar_dc, Vsbstar_dc_tmp, Vmb, us, usnew, Vmbnew, qeff1_dc, Voxm_dc, GdL_dc, eta_p_dc, Gvsat_dc, Gmob_dL_dc, x_ds_dc;
real x_m_dc, Gf_dc, Vdsat_dc, Udse_dc, SP_OV_xg, xs_ov, xd_ov, Vovs, Vovd, zg, TP, Fs1, Fs2, Fs3, Fs, Vm, Dch, arg2mina, psi_t, arg1;
real Dsi, Dgate, Igc0, igc, igcd_h, u0, x, u0_div_H, Bg, Ag, xsq, inv_x, ex, inv_ex, Sg, Igc, Igb, Vtovd, Igidl, Vtovs, Igisl;
real delVsat, Vsbstar_ac, xg_ac, qeff1_ac, Voxm_ac, alpha_ac, dps_ac, qim_ac, GdL_ac, H_ac, QG, QI, QD, QB, Fj, Fj2;
real QCLM, Qg, Qd, Qb, Qs, Qgs_ov, Qgd_ov, Qgb_ov, Qfgs, Qfgd, rgatenoise, rsourcenoise, rdrainnoise, rbulknoise, rwellnoise, rjundnoise;
real rjunsnoise;

// Global variables used in macros
real tme1, tme2;
real inv_GOV, SP_OV_eps, SP_OV_delta, mutau, nu;
real Q_EDGE_xsth, Q_EDGE_xth0, Q_EDGE_xth, Q_EDGE_n, Q_EDGE_n_inv, Q_EDGE_xgt, Q_EDGE_xgt0, Q_EDGE_xgt0e, Q_EDGE_qi0si, Q_EDGE_qi0;
real Q_EDGE_exp_x, Q_EDGE_d0, Q_EDGE_d0p, Q_EDGE_sqerr, Q_EDGE_errq;

// Global variables used in noise section
real N1, Nm1, Delta_N1, Sfl, t1, sqt2, t2, r, lc, lcinv2, g_ideal, mid, temp2_exc, wsat_exc, temp_exc, thesat1_exc, zsat_exc, Gvsat_exc;
real gfac, Sidexc, sqid, mig, migid0, migid, CGeff, sqig, c_igid, shot_igcsx, shot_igcdx, shot_igsov, shot_igdov, shot_iavl, jnoisex_s, jnoisex_d;
real shot_igs, shot_igd, anoisedge, N1edge, Nm1edge, Delta_N1edge, H0edge, t1edge, sqt2edge, t2edge, redge, lcedge, lcinv2edge;
real g_idealedge;

// Variables used in NQS-calculations
`ifdef NQSmodel
    integer SWNQS_i;
    real Gf_ac, xgm_dc, thesat1_dc, xgm_ac, x_m_ac, thesat1_ac, margin_dc, margin_ac;
    real Qp1_0, Qp2_0, Qp3_0, Qp4_0, Qp5_0, Qp6_0, Qp7_0, Qp8_0, Qp9_0, fk1, fk2, fk3, fk4, fk5, fk6, fk7, fk8, fk9, phi_p1, phi_p2, phi_p3;
    real phi_p4, phi_p5, phi_p6, phi_p7, phi_p8, phi_p9, Qp1, Qp2, Qp3, Qp4, Qp5, Qp6, Qp7, Qp8, Qp9, Qp0, QpN, QG_NQS, QS_NQS, QD_NQS, pd;
    real Gp, Gp2, a_factrp, marginp, x_sp, x_dp, zsat_nqs, dfQi, fQi, dQis, dQis_1, d2Qis, dQbs, dQy, d2Qy, dpsy2, ym, inorm, Tnorm, Qb_tmp;
    real QbSIGN, r_nqs, vnorm, vnorm_inv, NQS_xg1, NQS_yg, NQS_z, NQS_eta, NQS_a, NQS_c, NQS_tau, NQS_D0, NQS_xi, NQS_p, NQS_q, NQS_temp;
    real NQS_A_fac, NQS_xbar, NQS_w, NQS_x0, NQS_u, NQS_y0, xphi, fk0, thesat2, Fvsat, temp3, temp4, temp5, temp6, temp7, temp8, temp9;
`endif // NQSmodel

//ngspice-adms: move local variables here
real Invsa, Invsb, Invsaref, Invsbref, Kstressu0, rhobeta, rhobetaref, Kstressvth0;
real temp0, temp00, templ, tempw, Lx, Wx, loop, tmpa, tmpb;

real ijunbot, ijunsti, ijungat, qjunbot, qjunsti, qjungat;

real sigVds, dphit1, xgct, xsct0, xbct, xsbstar, xsct, dCTG, ct_fact, phit1, inv_phit1, xg_dc, alpha_dc, dps_dc, qim_dc;
real qim1_dc, H_dc, FdL_dc, Gvsatinv_dc, Ids, Iimpact, mavl, Igdov, Igsov, Igcd, Igcs, eta_p_ac, Gvsat_ac, Gmob_dL_ac, H0;
real COX_qm, ijun_s, ijunbot_s, ijunsti_s, ijungat_s, ijun_d, ijunbot_d, ijunsti_d, ijungat_d, qjun_s, qjunbot_s, qjunsti_s;
real qjungat_s, qjun_d, qjunbot_d, qjunsti_d, qjungat_d, jnoise_s, jnoise_d, Gmob_dc, xitsb_dc, Vdse_dc, Vsbstaredge, Vsbxedge;
real dphit1edge, phit1edge, inv_phit1edge, Vdspedge, delVgedge, xgedge, xbedge, dxthedge, xnedge_s, qseffedge, xnedge_d;
real qdseffedge, qdeffedge, qmeffedge, dsqredge, alphabmedge, Idsedge, Sfledge, midedge, sqidedge;
`ifdef SelfHeating
    real Pdiss, phit, BET_i, BETEDGE_i, nt0, nt, THESAT_T, THESATAC_T, Sfl_prefac, phit0edge, Gfedge2, lnGfedge2, Sfl_prefac_edge;
    real ntedge;
`endif // SelfHeating
real temp, temp1, temp2;

real FdL, qim1_1, r1, r2, s2, dL1;

real tmpv, vjv;

real Pdiss_s, Pdiss_d;

//`define SPcalcLocalVarDecl
real phib, G_0, Vsbstar, cfloc, thesatloc, axloc, alploc;
real Vsbx, xg, Dnsub, Gf, Gf2, inv_Gf2, xi, inv_xi, Ux, xn_s, delta_ns, margin, x_s, delta_1s, xi0s, xi1s;
real xi2s, Es, Ds, Ps, Rxcor, xgs, qis, qbs, rhob, GR, Eeffm, Mutmp, Gmob, xitsb, wsat, thesat1, phi_inf;
real ysat, za, Phi_0, asat, Phi_2, Phi_0_2, Phi0_Phi2, Phi_sat, Vdse, Udse, xn_d, k_ds, delta_nd, x_d, x_ds;
real pC, qC, dps, xi0d, Ed, Dd, x_m, Em, D_bar, Dm, Pm, xgm, eta_p, sqm, alpha, d0, x_pm, p_pd, q_pd, xi_pd;
real u_pd, km, km0, qim, qim1, qbm, qeff, qeff1, s1, dL, GdL, Gmob_dL, zsat, Gvsat, Gvsatinv, Voxm, alpha1, H;
real SP_S_temp, SP_S_temp1, SP_S_temp2;
real SP_S_yg, SP_S_ysub, SP_S_eta, SP_S_a, SP_S_c, SP_S_tau, SP_S_y0, SP_S_delta0, SP_S_delta1, SP_S_xi0;
real SP_S_xi1, SP_S_xi2, SP_S_pC, SP_S_qC, SP_xg1, SP_S_A_fac, SP_S_xbar, SP_S_w, SP_S_x1, SP_S_bx, SP_S_b;
real SP_S_x0;

/* declaration of variables needed in macro "calcerfcexpmtat" */
real ysq, terfc, erfcpos;

/* declaration of variables needed in hypfunction 5 */
real h1, h2, h2d, h3, h4, h5;

/* declaration of variables calculated outside macro "juncapfunction", voltage-dependent part */
real idmult, vj, z, zinv, two_psistar, vjlim, vjsrh, vbbt, vav;

/* declaration of variables used within macro "juncapfunction" */
real tmp, id;
real isrh, vbi_minus_vjsrh, wsrhstep, dwsrh, wsrh, wdep, asrh;
real itat, btat, twoatatoverthreebtat, umaxbeforelimiting, umax, sqrtumax, umaxpoweronepointfive;
real wgamma, wtat, ktat, ltat, mtat, xerfc, erfctimesexpmtat, gammamax;
real ibbt, Fmaxr;
real fbreakdown;

//  --------------------------------------------------------------------------------------------------------------
//  Variables for operating point info
//  --------------------------------------------------------------------------------------------------------------
real id_op, is, ig, ib, P_D, facvsb, facvsb0, sig1k, vth_i, vts_i, ids_i;
`OPP(ctype             ,""             ,"Flag for channel type")
`OPP(sdint             ,""             ,"Flag for source-drain interchange")
`OPP(ise               ,"A"            ,"Total source current")
`OPP(ige               ,"A"            ,"Total gate current")
`OPP(ide               ,"A"            ,"Total drain current")
`OPP(ibe               ,"A"            ,"Total bulk current")
`OPP(ids               ,"A"            ,"Drain current, excl. edge transistor currents, avalanche, tunnel, GISL, GIDL, and junction currents")
`OPP(idb               ,"A"            ,"Drain to bulk current")
`OPP(isb               ,"A"            ,"Source to bulk current")
`OPP(igs               ,"A"            ,"Gate-source tunneling current")
`OPP(igd               ,"A"            ,"Gate-drain tunneling current")
`OPP(igb               ,"A"            ,"Gate-bulk tunneling current")
`OPP(idedge            ,"A"            ,"Drain current of edge transistors")
`OPP(igcs              ,"A"            ,"Gate-channel tunneling current (source component)")
`OPP(igcd              ,"A"            ,"Gate-channel tunneling current (drain component)")
`OPP(iavl              ,"A"            ,"Substrate current due to weak avelanche")
`OPP(igisl             ,"A"            ,"Gate-induced source leakage current")
`OPP(igidl             ,"A"            ,"Gate-induced drain leakage current")
`OPP(ijs               ,"A"            ,"Total source junction current")
`OPP(ijsbot            ,"A"            ,"Source junction current (bottom component)")
`OPP(ijsgat            ,"A"            ,"Source junction current (gate-edge component)")
`OPP(ijssti            ,"A"            ,"Source junction current (STI-edge component)")
`OPP(ijd               ,"A"            ,"Total drain junction current")
`OPP(ijdbot            ,"A"            ,"Drain junction current (bottom component)")
`OPP(ijdgat            ,"A"            ,"Drain junction current (gate-edge component)")
`OPP(ijdsti            ,"A"            ,"Drain junction current (STI-edge component)")
`OPP(vds               ,"V"            ,"Drain-source voltage")
`OPP(vgs               ,"V"            ,"Gate-source voltage")
`OPP(vsb               ,"V"            ,"Source-bulk voltage")
`OPP(vto               ,"V"            ,"Zero-bias threshold voltage")
`OPP(vts               ,"V"            ,"Threshold voltage including back bias effects")
`OPP(vth               ,"V"            ,"Threshold voltage including back bias and drain bias effects")
`OPP(vgt               ,"V"            ,"Effective gate drive voltage including back bias and drain bias effects")
`OPP(vdss              ,"V"            ,"Drain saturation voltage at actual bias")
`OPP(vsat              ,""             ,"Saturation limit")
`ifdef OPderiv
    `OPP(gm                ,"1/Ohm"        ,"Transconductance")
    `OPP(gmb               ,"1/Ohm"        ,"Substrate transconductance")
    `OPP(gds               ,"1/Ohm"        ,"Output conductance")
    `OPP(gjs               ,"1/Ohm"        ,"Source junction conductance")
    `OPP(gjd               ,"1/Ohm"        ,"Drain junction conductance")
    `OPP(cdd               ,"F"            ,"Drain capacitance")
    `OPP(cdg               ,"F"            ,"Drain-gate capacitance")
    `OPP(cds               ,"F"            ,"Drain-source capacitance")
    `OPP(cdb               ,"F"            ,"Drain-bulk capacitance")
    `OPP(cgd               ,"F"            ,"Gate-drain capacitance")
    `OPP(cgg               ,"F"            ,"Gate capacitance")
    `OPP(cgs               ,"F"            ,"Gate-source capacitance")
    `OPP(cgb               ,"F"            ,"Gate-bulk capacitance")
    `OPP(csd               ,"F"            ,"Source-drain capacitance")
    `OPP(csg               ,"F"            ,"Source-gate capacitance")
    `OPP(css               ,"F"            ,"Source capacitance")
    `OPP(csb               ,"F"            ,"Source-bulk capacitance")
    `OPP(cbd               ,"F"            ,"Bulk-drain capacitance")
    `OPP(cbg               ,"F"            ,"Bulk-gate capacitance")
    `OPP(cbs               ,"F"            ,"Bulk-source capacitance")
    `OPP(cbb               ,"F"            ,"Bulk capacitance")
    `OPP(cgsol             ,"F"            ,"Total gate-source overlap capacitance")
    `OPP(cgdol             ,"F"            ,"Total gate-drain overlap capacitance")
    `OPP(cjs               ,"F"            ,"Total source junction capacitance")
    `OPP(cjsbot            ,"F"            ,"Source junction capacitance (bottom component)")
    `OPP(cjsgat            ,"F"            ,"Source junction capacitance (gate-edge component)")
    `OPP(cjssti            ,"F"            ,"Source junction capacitance (STI-edge component)")
    `OPP(cjd               ,"F"            ,"Total drain junction capacitance")
    `OPP(cjdbot            ,"F"            ,"Drain junction capacitance (bottom component)")
    `OPP(cjdgat            ,"F"            ,"Drain junction capacitance (gate-edge component)")
    `OPP(cjdsti            ,"F"            ,"Drain junction capacitance (STI-edge component)")
`endif // OPderiv
`OPP(weff              ,"m"            ,"Effective channel width for geometrical models")
`OPP(leff              ,"m"            ,"Effective channel length for geometrical models")
`ifdef OPderiv
    `OPP(u                 ,""             ,"Transistor gain")
    `OPP(rout              ,"Ohm"          ,"Small-signal output resistance")
    `OPP(vearly            ,"V"            ,"Equivalent Early voltage")
    `OPP(beff              ,"A/V^2"        ,"Gain factor")
    `OPP(fug               ,"Hz"           ,"Unity gain frequency at actual bias")
    `OPP(rg_op             ,"Ohm"          ,"Gate resistance")
    `OPP(sfl               ,"A^2/Hz"       ,"Flicker noise current spectral density at 1 Hz")
    `OPP(sqrtsff           ,"V/sqrt(Hz)"   ,"Input-referred RMS white noise voltage spectral density at 1 kHz")
    `OPP(sqrtsfw           ,"V/sqrt(Hz)"   ,"Input-referred RMS white noise voltage spectral density")
    `OPP(sid               ,"A^2/Hz"       ,"White noise current spectral density")
    `OPP(sig               ,"A^2/Hz"       ,"Induced gate noise current spectral density at 1 Hz")
    `OPP(cigid             ,""             ,"Imaginary part of correlation coefficient between Sig and Sid")
    `OPP(fknee             ,"Hz"           ,"Cross-over frequency above which white noise is dominant")
    `OPP(sigs              ,"A^2/Hz"       ,"Gate-source current noise spectral density")
    `OPP(sigd              ,"A^2/Hz"       ,"Gate-drain current noise spectral density")
    `OPP(siavl             ,"A^2/Hz"       ,"Impact ionization current noise spectral density")
    `OPP(ssi               ,"A^2/Hz"       ,"Total source junction current noise spectral density")
    `OPP(sdi               ,"A^2/Hz"       ,"Total drain junction current noise spectral density")
    `OPP(sfledge           ,"A^2/Hz"       ,"Flicker noise current spectral density at 1 Hz of edge transistors")
    `OPP(sidedge           ,"A^2/Hz"       ,"White noise current spectral density of edge transistors")
`endif // OPderiv
// local parameters after scaling, T-scaling, and clipping
`OPP(lp_vfb            ,"V"            ,"Local parameter VFB after T-scaling and clipping")
`OPP(lp_stvfb          ,"V/K"          ,"Local parameter STVFB after clipping")
`OPP(lp_st2vfb         ,"K^-1"         ,"Local parameter ST2VFB after clipping")
`OPP(lp_tox            ,"m"            ,"Local parameter TOX after clipping")
`OPP(lp_epsrox         ,""             ,"Local parameter EPSROX after clipping")
`OPP(lp_neff           ,"m^-3"         ,"Local parameter NEFF after clipping")
`OPP(lp_facneffac      ,""             ,"Local parameter FACNEFFAC after clipping")
`OPP(lp_gfacnud        ,""             ,"Local parameter GFACNUD after clipping")
`OPP(lp_vsbnud         ,"V"            ,"Local parameter VSBNUD after clipping")
`OPP(lp_dvsbnud        ,"V"            ,"Local parameter DVSBNUD after clipping")
`OPP(lp_vnsub          ,"V"            ,"Local parameter VNSUB after clipping")
`OPP(lp_nslp           ,"V"            ,"Local parameter NSLP after clipping")
`OPP(lp_dnsub          ,"V^-1"         ,"Local parameter DNSUB after clipping")
`OPP(lp_dphib          ,"V"            ,"Local parameter DPHIB after clipping")
`OPP(lp_delvtac        ,"V"            ,"Local parameter DELVTAC after clipping")
`OPP(lp_np             ,"m^-3"         ,"Local parameter NP after clipping")
`OPP(lp_toxov          ,"m"            ,"Local parameter TOXOV after clipping")
`OPP(lp_toxovd         ,"m"            ,"Local parameter TOXOVD after clipping")
`OPP(lp_nov            ,"m^-3"         ,"Local parameter NOV after clipping")
`OPP(lp_novd           ,"m^-3"         ,"Local parameter NOVD after clipping")
`OPP(lp_ct             ,""             ,"Local parameter CT after clipping")
`OPP(lp_ctg            ,""             ,"Local parameter CTG after clipping")
`OPP(lp_ctb            ,""             ,"Local parameter CTB after clipping")
`OPP(lp_stct           ,""             ,"Local parameter STCT after clipping")
`OPP(lp_cf             ,""             ,"Local parameter CF after clipping")
`OPP(lp_cfac           ,""             ,"Local parameter CFAC after clipping")
`OPP(lp_cfd            ,"V^-1"         ,"Local parameter CFD after clipping")
`OPP(lp_cfb            ,"V^-1"         ,"Local parameter CFB after clipping")
`OPP(lp_psce           ,""             ,"Local parameter PSCE after clipping")
`OPP(lp_psceb          ,"V^-1"         ,"Local parameter PSCEB after clipping")
`OPP(lp_psced          ,"V^-1"         ,"Local parameter PSCED after clipping")
`OPP(lp_betn           ,"m^2/(V s)"    ,"Local parameter BETN after T-scaling and clipping")
`OPP(lp_stbet          ,""             ,"Local parameter STBET after clipping")
`OPP(lp_mue            ,"m/V"          ,"Local parameter MUE after T-scaling and clipping")
`OPP(lp_stmue          ,""             ,"Local parameter STMUE after clipping")
`OPP(lp_themu          ,""             ,"Local parameter THEMU after T-scaling and clipping")
`OPP(lp_stthemu        ,""             ,"Local parameter STTHEMU after clipping")
`OPP(lp_cs             ,""             ,"Local parameter CS after T-scaling and clipping")
`OPP(lp_stcs           ,""             ,"Local parameter STCS after clipping")
`OPP(lp_thecs          ,""             ,"Local parameter THECS after T-scaling and clipping")
`OPP(lp_stthecs        ,""             ,"Local parameter STTHECS after clipping")
`OPP(lp_xcor           ,"V^-1"         ,"Local parameter XCOR after T-scaling and clipping")
`OPP(lp_stxcor         ,""             ,"Local parameter STXCOR after clipping")
`OPP(lp_feta           ,""             ,"Local parameter FETA after clipping")
`OPP(lp_rs             ,"Ohm"          ,"Local parameter RS after T-scaling and clipping")
`OPP(lp_strs           ,""             ,"Local parameter STRS after clipping")
`OPP(lp_rsb            ,"V^-1"         ,"Local parameter RSB after clipping")
`OPP(lp_rsg            ,"V^-1"         ,"Local parameter RSG after clipping")
`OPP(lp_thesat         ,"V^-1"         ,"Local parameter THESAT after T-scaling and clipping")
`OPP(lp_thesatac       ,"V^-1"         ,"Local parameter THESATAC after T-scaling and clipping")
`OPP(lp_stthesat       ,""             ,"Local parameter STTHESAT after clipping")
`OPP(lp_thesatb        ,"V^-1"         ,"Local parameter THESATB after clipping")
`OPP(lp_thesatg        ,"V^-1"         ,"Local parameter THESATG after clipping")
`OPP(lp_ax             ,""             ,"Local parameter AX after clipping")
`OPP(lp_axac           ,""             ,"Local parameter AXAC after clipping")
`OPP(lp_alp            ,""             ,"Local parameter ALP after clipping")
`OPP(lp_alpac          ,""             ,"Local parameter ALPAC after clipping")
`OPP(lp_alp1           ,"V"            ,"Local parameter ALP1 after clipping")
`OPP(lp_alp2           ,"V^-1"         ,"Local parameter ALP2 after clipping")
`OPP(lp_vp             ,"V"            ,"Local parameter VP after clipping")
`OPP(lp_a1             ,""             ,"Local parameter A1 after clipping")
`OPP(lp_a2             ,"V"            ,"Local parameter A2 after T-scaling and clipping")
`OPP(lp_sta2           ,""             ,"Local parameter STA2 after clipping")
`OPP(lp_a3             ,""             ,"Local parameter A3 after clipping")
`OPP(lp_a4             ,"1/sqrt(V)"    ,"Local parameter A4 after clipping")
`OPP(lp_gco            ,""             ,"Local parameter GCO after clipping")
`OPP(lp_iginv          ,"A"            ,"Local parameter IGINV after T-scaling and clipping")
`OPP(lp_igov           ,"A"            ,"Local parameter IGOV after T-scaling and clipping")
`OPP(lp_igovd          ,"A"            ,"Local parameter IGOVD after T-scaling and clipping")
`OPP(lp_stig           ,""             ,"Local parameter STIG after clipping")
`OPP(lp_gc2            ,""             ,"Local parameter GC2 after clipping")
`OPP(lp_gc3            ,""             ,"Local parameter GC3 after clipping")
`OPP(lp_gc2ov          ,""             ,"Local parameter GC2OV after clipping")
`OPP(lp_gc3ov          ,""             ,"Local parameter GC3OV after clipping")
`OPP(lp_chib           ,"V"            ,"Local parameter CHIB after clipping")
`OPP(lp_agidl          ,"A/V^3"        ,"Local parameter AGIDL after clipping")
`OPP(lp_agidld         ,"A/V^3"        ,"Local parameter AGIDLD after clipping")
`OPP(lp_bgidl          ,"V"            ,"Local parameter BGIDL after T-scaling and clipping")
`OPP(lp_bgidld         ,"V"            ,"Local parameter BGIDLD after T-scaling and clipping")
`OPP(lp_stbgidl        ,"V/K"          ,"Local parameter STBGIDL after clipping")
`OPP(lp_stbgidld       ,"V/K"          ,"Local parameter STBGIDLD after clipping")
`OPP(lp_cgidl          ,""             ,"Local parameter CGIDL after clipping")
`OPP(lp_cgidld         ,""             ,"Local parameter CGIDLD after clipping")
`OPP(lp_cox            ,"F"            ,"Local parameter COX after clipping")
`OPP(lp_cgov           ,"F"            ,"Local parameter CGOV after clipping")
`OPP(lp_cgovd          ,"F"            ,"Local parameter CGOVD after clipping")
`OPP(lp_cgbov          ,"F"            ,"Local parameter CGBOV after clipping")
`OPP(lp_cfr            ,"F"            ,"Local parameter CFR after clipping")
`OPP(lp_cfrd           ,"F"            ,"Local parameter CFRD after clipping")
`OPP(lp_fnt            ,""             ,"Local parameter FNT after clipping")
`OPP(lp_fntexc         ,""             ,"Local parameter FNTEXC after clipping")
`OPP(lp_nfa            ,"1/(V m^4)"    ,"Local parameter NFA after clipping")
`OPP(lp_nfb            ,"1/(V m^4)"    ,"Local parameter NFB after clipping")
`OPP(lp_nfc            ,"V^-1"         ,"Local parameter NFC after clipping")
`OPP(lp_ef             ,""             ,"Local parameter EF after clipping")
`OPP(lp_vfbedge        ,"V"            ,"Local parameter VFBEDGE after T-scaling and clipping")
`OPP(lp_stvfbedge      ,"V/K"          ,"Local parameter STVFBEDGE after clipping")
`OPP(lp_dphibedge      ,"V"            ,"Local parameter DPHIBEDGE after clipping")
`OPP(lp_neffedge       ,"m^-3"         ,"Local parameter NEFFEDGE after clipping")
`OPP(lp_ctedge         ,""             ,"Local parameter CTEDGE after clipping")
`OPP(lp_betnedge       ,"m^2/V/s"      ,"Local parameter BETNEDGE after T-scaling and clipping")
`OPP(lp_stbetedge      ,""             ,"Local parameter STBETEDGE after clipping")
`OPP(lp_psceedge       ,""             ,"Local parameter PSCEEDGE after clipping")
`OPP(lp_pscebedge      ,"V^-1"         ,"Local parameter PSCEBEDGE after clipping")
`OPP(lp_pscededge      ,"V^-1"         ,"Local parameter PSCEDEDGE after clipping")
`OPP(lp_cfedge         ,"V"            ,"Local parameter CFEDGE after clipping")
`OPP(lp_cfdedge        ,"V^-1"         ,"Local parameter CFDEDGE after clipping")
`OPP(lp_cfbedge        ,"V^-1"         ,"Local parameter CFBEDGE after clipping")
`OPP(lp_fntedge        ,""             ,"Local parameter FNTEDGE after clipping")
`OPP(lp_nfaedge        ,"1/(V m^4)"    ,"Local parameter NFAEDGE after clipping")
`OPP(lp_nfbedge        ,"1/(V m^4)"    ,"Local parameter NFBEDGE after clipping")
`OPP(lp_nfcedge        ,"V^-1"         ,"Local parameter NFCEDGE after clipping")
`OPP(lp_efedge         ,""             ,"Local parameter EFEDGE after clipping")
`OPP(lp_rg             ,"Ohm"          ,"Local parameter RG after clipping")
`OPP(lp_rse            ,"Ohm"          ,"Local parameter RSE after clipping")
`OPP(lp_rde            ,"Ohm"          ,"Local parameter RDE after clipping")
`OPP(lp_rbulk          ,"Ohm"          ,"Local parameter RBULK after clipping")
`OPP(lp_rwell          ,"Ohm"          ,"Local parameter RWELL after clipping")
`OPP(lp_rjuns          ,"Ohm"          ,"Local parameter RJUNS after clipping")
`OPP(lp_rjund          ,"Ohm"          ,"Local parameter RJUND after clipping")
`ifdef SelfHeating
    `OPP(lp_rth            ,"K/W"          ,"Local parameter RTH after T-scaling and clipping")
    `OPP(lp_cth            ,"J/K"          ,"Local parameter CTH after clipping")
    `OPP(lp_strth          ,""             ,"Local parameter STRTH after clipping")
    `OPP(pdiss             ,"W"            ,"Power dissipation")
    `OPP(dtsh              ,"K"            ,"Temperature rise due to self heating")
`endif // SelfHeating
`OPP(tk                ,"K"            ,"Device Temperature")
`OPP(cjosbot           ,"F"            ,"Bottom component of total zero-bias source junction capacitance at device temperature")
`OPP(cjossti           ,"F"            ,"STI-edge component of total zero-bias source junction capacitance at device temperature")
`OPP(cjosgat           ,"F"            ,"Gate-edge component of total zero-bias source junction capacitance at device temperature")
`OPP(vbisbot           ,"V"            ,"Built-in voltage of source-side bottom junction at device temperature")
`OPP(vbissti           ,"V"            ,"Built-in voltage of source-side STI-edge junction at device temperature")
`OPP(vbisgat           ,"V"            ,"Built-in voltage of source-side gate-edge junction at device temperature")
`OPP(idsatsbot         ,"A"            ,"Total source-side bottom junction saturation current")
`OPP(idsatssti         ,"A"            ,"Total source-side STI-edge junction saturation current")
`OPP(idsatsgat         ,"A"            ,"Total source-side gate-edge junction saturation current")
`OPP(cjosbotd          ,"F"            ,"Bottom component of total zero-bias drain junction capacitance at device temperature")
`OPP(cjosstid          ,"F"            ,"STI-edge component of total zero-bias drain junction capacitance at device temperature")
`OPP(cjosgatd          ,"F"            ,"Gate-edge component of total zero-bias drain junction capacitance at device temperature")
`OPP(vbisbotd          ,"V"            ,"Built-in voltage of drain-side bottom junction at device temperature")
`OPP(vbisstid          ,"V"            ,"Built-in voltage of drain-side STI-edge junction at device temperature")
`OPP(vbisgatd          ,"V"            ,"Built-in voltage of drain-side gate-edge junction at device temperature")
`OPP(idsatsbotd        ,"A"            ,"Total drain-side bottom junction saturation current")
`OPP(idsatsstid        ,"A"            ,"Total drain-side STI-edge junction saturation current")
`OPP(idsatsgatd        ,"A"            ,"Total drain-side gate-edge junction saturation current")
`ifdef NQSmodel
    `OPP(lp_munqs          ,""             ,"Local parameter MUNQS after clipping")
`endif // NQSmodel

//  --------------------------------------------------------------------------------------------------------------
//  Analog block with all calculations and contribs
//  --------------------------------------------------------------------------------------------------------------
analog begin

    //  --------------------------------------------------------------------------------------------------------------
    //  Definition of bias/instance independent model variables
    //  --------------------------------------------------------------------------------------------------------------
    `INITIAL_MODEL
    begin : initial_model

        // Clipping and rounding of switch parameters
        if (`PGIVEN(nmos)) begin
            CHNL_TYPE = `NMOS;
        end else if (`PGIVEN(pmos)) begin
            CHNL_TYPE = `PMOS;
        end else begin
            CHNL_TYPE = (`PGIVEN(TYPE)) ? TYPE : `NMOS;
        end
        //$strobe("CHNL_TYPE %d", CHNL_TYPE);
        EPSSI       = `EPSO * `EPSRSI;
        SWGEO_i     =  floor(`CLIP_BOTH(SWGEO,     0.0, 2.0) + 0.5);
        SWIGATE_i   =  floor(`CLIP_BOTH(SWIGATE,   0.0, 2.0) + 0.5);
        SWIMPACT_i  =  floor(`CLIP_BOTH(SWIMPACT,  0.0, 1.0) + 0.5);
        SWGIDL_i    =  floor(`CLIP_BOTH(SWGIDL,    0.0, 1.0) + 0.5);
        SWJUNCAP_i  =  floor(`CLIP_BOTH(SWJUNCAP,  0.0, 3.0) + 0.5);
        SWJUNASYM_i =  floor(`CLIP_BOTH(SWJUNASYM, 0.0, 1.0) + 0.5);
        SWNUD_i     =  floor(`CLIP_BOTH(SWNUD,     0.0, 2.0) + 0.5);
        SWEDGE_i    =  floor(`CLIP_BOTH(SWEDGE,    0.0, 1.0) + 0.5);
        SWDELVTAC_i =  floor(`CLIP_BOTH(SWDELVTAC, 0.0, 1.0) + 0.5);
        SWQSAT_i    =  floor(`CLIP_BOTH(SWQSAT, 0.0, 1.0) + 0.5);
        SWQPART_i   =  floor(`CLIP_BOTH(SWQPART, 0.0, 1.0) + 0.5);
        SWIGN_i     =  floor(`CLIP_BOTH(SWIGN, 0.0, 1.0) + 0.5);
        QMC_i       = `CLIP_LOW(QMC, 0.0);
        `ifdef NQSmodel
            if (SWNQS < 0.5) begin
                SWNQS_i     =  0;
            end else begin
                if (SWNQS < 1.5) begin
                    SWNQS_i     =  1;
                end else begin
                    if (SWNQS < 2.5) begin
                        SWNQS_i     =  2;
                    end else begin
                        if (SWNQS < 4.0) begin
                            SWNQS_i     =  3;
                        end else begin
                            if (SWNQS < 7.0) begin
                                SWNQS_i     =  5;
                            end else begin
                                SWNQS_i     =  9;
                            end
                        end
                    end
                end
            end
            inorm       =  1.0e-12;
            r_nqs       =  1.0e3;
            vnorm       =  10.0;
            vnorm_inv   =  1.0 / vnorm;
        `endif // NQSmodel

        // Clipping of global model parameters
        TOXO_i      = `CLIP_LOW(TOXO, 1.0e-10);
        EPSROXO_i   = `CLIP_LOW(EPSROXO, 1.0);
        NSUBO_i     = `CLIP_LOW(NSUBO, 1.0e20);
        WSEG_i      = `CLIP_LOW(WSEG, 1.0e-10);
        NPCK_i      = `CLIP_LOW(NPCK, 0.0);
        WSEGP_i     = `CLIP_LOW(WSEGP, 1.0e-10);
        LPCK_i      = `CLIP_LOW(LPCK, 1.0e-10);
        TOXOVO_i    = `CLIP_LOW(TOXOVO, 1.0e-10);
        TOXOVDO_i   = `CLIP_LOW(TOXOVDO, 1.0e-10);
        LOV_i       = `CLIP_LOW(LOV, 0.0);
        LOVD_i      = `CLIP_LOW(LOVD, 0.0);
        LP1_i       = `CLIP_LOW(LP1, 1.0e-10);
        LP2_i       = `CLIP_LOW(LP2, 1.0e-10);
        WBET_i      = `CLIP_LOW(WBET, 1.0e-10);
        AXL_i       = `CLIP_LOW(AXL, 0.0);
        ALP1L2_i    = `CLIP_LOW(ALP1L2, 0.0);
        ALP2L2_i    = `CLIP_LOW(ALP2L2, 0.0);
        SAREF_i     = `CLIP_LOW(SAREF, 1.0e-9);
        SBREF_i     = `CLIP_LOW(SBREF, 1.0e-9);
        KVSAT_i     = `CLIP_BOTH(KVSAT, -1.0, 1.0);
        LLODKUO_i   = `CLIP_LOW(LLODKUO, 0.0);
        WLODKUO_i   = `CLIP_LOW(WLODKUO, 0.0);
        LLODVTH_i   = `CLIP_LOW(LLODVTH, 0.0);
        WLODVTH_i   = `CLIP_LOW(WLODVTH, 0.0);
        LODETAO_i   = `CLIP_LOW(LODETAO, 0.0);
        SCREF_i     = `CLIP_LOW(SCREF, 0.0);
        WEB_i       =  WEB;
        WEC_i       =  WEC;
        RSHG_i      = `CLIP_LOW(RSHG, 0.0);
        RSH_i       = `CLIP_LOW(RSH, 0.0);
        RSHD_i      = `CLIP_LOW(RSHD, 0.0);
        RINT_i      = `CLIP_LOW(RINT, 0.0);
        RVPOLY_i    = `CLIP_LOW(RVPOLY, 0.0);
        NSUBEDGEO_i = `CLIP_LOW(NSUBEDGEO, 1.0e20);
        LPEDGE_i    = `CLIP_LOW(LPEDGE, 1.0e-10);

        // Definition of global-binning parameters for the charge model in the case of separate calculation in saturation
        `DefACparam(CFACL_i,        CFL,        CFACL)
        `DefACparam(CFACLEXP_i,     CFLEXP,     CFACLEXP)
        `DefACparam(CFACW_i,        CFW,        CFACW)
        `DefACparam(THESATACO_i,    THESATO,    THESATACO)
        `DefACparam(THESATACL_i,    THESATL,    THESATACL)
        `DefACparam(THESATACLEXP_i, THESATLEXP, THESATACLEXP)
        `DefACparam(THESATACW_i,    THESATW,    THESATACW)
        `DefACparam(THESATACLW_i,   THESATLW,   THESATACLW)
        `DefACparam(AXACO_i,        AXO,        AXACO)
        `DefACparam(AXACL_i,        AXL_i,      AXACL)
        AXACL_i     = `CLIP_LOW(AXACL_i, 0.0);
        `DefACparam(ALPACL_i,       ALPL,       ALPACL)
        `DefACparam(ALPACLEXP_i,    ALPLEXP,    ALPACLEXP)
        `DefACparam(ALPACW_i,       ALPW,       ALPACW)
        `DefACparam(POCFAC_i,       POCF,       POCFAC)
        `DefACparam(PLCFAC_i,       PLCF,       PLCFAC)
        `DefACparam(PWCFAC_i,       PWCF,       PWCFAC)
        `DefACparam(PLWCFAC_i,      PLWCF,      PLWCFAC)
        `DefACparam(POTHESATAC_i,   POTHESAT,   POTHESATAC)
        `DefACparam(PLTHESATAC_i,   PLTHESAT,   PLTHESATAC)
        `DefACparam(PWTHESATAC_i,   PWTHESAT,   PWTHESATAC)
        `DefACparam(PLWTHESATAC_i,  PLWTHESAT,  PLWTHESATAC)
        `DefACparam(POAXAC_i,       POAX,       POAXAC)
        `DefACparam(PLAXAC_i,       PLAX,       PLAXAC)
        `DefACparam(PWAXAC_i,       PWAX,       PWAXAC)
        `DefACparam(PLWAXAC_i,      PLWAX,      PLWAXAC)
        `DefACparam(POALPAC_i,      POALP,      POALPAC)
        `DefACparam(PLALPAC_i,      PLALP,      PLALPAC)
        `DefACparam(PWALPAC_i,      PWALP,      PWALPAC)
        `DefACparam(PLWALPAC_i,     PLWALP,     PLWALPAC)
        `DefACparam(KVSATAC_i,      KVSAT,      KVSATAC)
        KVSATAC_i     = `CLIP_BOTH(KVSATAC_i, -1.0, 1.0);

        // Transistor temperature
        TR_i        = `CLIP_LOW(TR, -273.0);
        TKR         = `KELVINCONVERSION + TR_i;
        TKA         =  $temperature + DTA;
        rTa         =  TKA / TKR;
        delTa       =  TKA - TKR;
        phita       =  TKA * `KBOL / `QELE;
        inv_phita   =  1.0 / phita;
        `ifdef SelfHeating
            // do nothing
        `else // SelfHeating
            TKD         =  TKA;
            `TempInitialize
        `endif // SelfHeating

        // JUNCAP2
        `include "JUNCAP200_InitModel.include"

    end // initial_model

    //  --------------------------------------------------------------------------------------------------------------
    //  Definition of instance dependent and bias independent variables
    //  --------------------------------------------------------------------------------------------------------------
    `INITIAL_INSTANCE
    begin : initial_instance

        //ngspice-adms: JUNCAP2 Instance parameter handling
        IFACTOR_i    = `CLIP_LOW( IFACTOR    ,`IFACTOR_cliplow);
        CFACTOR_i    = `CLIP_LOW( CFACTOR    ,`CFACTOR_cliplow);

        // Declaration of local variables
//        real Invsa, Invsb, Invsaref, Invsbref, Kstressu0, rhobeta, rhobetaref, Kstressvth0;
//        real temp0, temp00, templ, tempw, Lx, Wx, loop, tmpa, tmpb;

        // Instance variables
        NF_i        =  1.0;
        invNF       =  1.0;
        LE          =  0.0;
        WE          =  0.0;
        L_i         =  L;
        W_i         =  W;
        SA_i        =  SA;
        SB_i        =  SB;
        SD_i        =  SD;
        SC_i        =  SC;
        XGW_i       =  XGW;
        ABSOURCE_i  =  ABSOURCE;
        LSSOURCE_i  =  LSSOURCE;
        LGSOURCE_i  =  LGSOURCE;
        ABDRAIN_i   =  ABDRAIN;
        LSDRAIN_i   =  LSDRAIN;
        LGDRAIN_i   =  LGDRAIN;
        AS_i        =  AS;
        PS_i        =  PS;
        AD_i        =  AD;
        PD_i        =  PD;
        JW_i        =  JW;

        // Clipping of the instance parameters
        if ((SWGEO_i == 1) || (SWGEO_i == 2)) begin
            NF_i        = `CLIP_LOW(NF, 1.0);
            NF_i        =  floor(NF_i + 0.5); // round to nearest integer
            invNF       =  1.0 / NF_i;
        end
        L_i          = `CLIP_LOW(L_i, 1.0e-9);
        W_i          = `CLIP_LOW(W_i * invNF, 1.0e-9);
        SCA_i        = `CLIP_LOW(SCA, 0.0);
        SCB_i        = `CLIP_LOW(SCB, 0.0);
        SCC_i        = `CLIP_LOW(SCC, 0.0);
        NGCON_i      =  (NGCON < 1.5) ? 1.0 : 2.0;

        // Internal local parameters
        `include "PSP103_scaling.include"

        // Local process parameters
        EPSOX        = `EPSO * EPSROX_i;
        CoxPrime     =  EPSOX / TOX_i;
        tox_sq       =  TOX_i * TOX_i;
        Cox_over_q   =  CoxPrime / `QELE;
        NEFFAC_i     =  FACNEFFAC_i * NEFF_i;
        NEFFAC_i     = `CLIP_BOTH(NEFFAC_i, 1.0e20, 1.0e26);

        // QM corrections: initially calculated in PSP103_macrodefs.include (PSP103.3)
        qq           =  0.0;
        if (QMC_i > 0.0) begin
            qq           =  0.4 * `QMN * QMC_i * pow(CoxPrime, `twoThirds);
            if (CHNL_TYPE==`PMOS) begin
                qq           = `QMP / `QMN * qq;
            end
        end

        // Electrical field parameters
        E_eff0       =  1.0e-8 * CoxPrime / EPSSI;
        eta_mu       =  0.5 * FETA_i;
        eta_mu1      =  0.5;
        if (CHNL_TYPE == `PMOS) begin
            eta_mu       =  `oneThird * FETA_i;
            eta_mu1      =  `oneThird;
        end

        // Linear-saturation transition parameter
        inv_AX       =  1.0 / AX_i;

        // CLM parameter
        inv_VP       =  1.0 / VP_i;

        // Gate overlap
        CoxovPrime   =  EPSOX / TOXOV_i;
        CoxovPrime_d =  EPSOX / TOXOVD_i;
        GOV_s        =  sqrt(2.0 * `QELE * NOV_i * EPSSI * inv_phita) / CoxovPrime;
        GOV_d        =  sqrt(2.0 * `QELE * NOVD_i * EPSSI * inv_phita) / CoxovPrime_d;
        GOV2_s       =  GOV_s * GOV_s;
        GOV2_d       =  GOV_d * GOV_d;
        `sp_ovInit(GOV_s, GOV2_s, SP_OV_eps2_s, SP_OV_a_s, SP_OV_delta1_s)
        `sp_ovInit(GOV_d, GOV2_d, SP_OV_eps2_d, SP_OV_a_d, SP_OV_delta1_d)

        // Temperature scaling variables
        `ifdef SelfHeating
            // do nothing
        `else // SelfHeating
            // Initialize variables of edge transistor
            `TempScaling
        `endif // SelfHeating

        // Gate to channel leakage parameters
        inv_CHIB     =  1.0 / CHIB_i;
        B_fact       =  4.0 * `oneThird * sqrt(2.0 * `QELE * `MELE * CHIB_i) / `HBAR;
        BCH          =  B_fact * TOX_i;
        BOV          =  B_fact * TOXOV_i;
        BOV_d        =  B_fact * TOXOVD_i;
        GCQ          =  0.0;
        if (GC3_i < 0) begin
            GCQ          =  -0.495 * GC2_i / GC3_i;
        end
        GCQOV        =  GCQ;
        if (SWIGATE_i == 2) begin
            GCQOV          =  0.0;
            if (GC3OV_i < 0.0) begin
                GCQOV          =  -0.495 * GC2OV_i / GC3OV_i;
            end
        end
        tf_ig        =  pow(rTa, STIG_i);
        IGINV_i      =  IGINV_i * tf_ig;
        IGOV_i       =  IGOV_i * tf_ig;
        IGOVD_i      =  IGOVD_i * tf_ig;

        // GIDL parameters
        AGIDLs       =  AGIDL_i * 4.0e-18 / (TOXOV_i * TOXOV_i);
        AGIDLDs      =  AGIDLD_i * 4.0e-18 / (TOXOVD_i * TOXOVD_i);
        B_fact       = `MAX(1.0 + STBGIDL_i * delTa, 0.0);
        BGIDL_T      =  BGIDL_i * B_fact;
        BGIDLs       =  BGIDL_T * TOXOV_i * 5.0e8;
        B_fact       = `MAX(1.0 + STBGIDLD_i * delTa, 0.0);
        BGIDLD_T     =  BGIDLD_i * B_fact;
        BGIDLDs      =  BGIDLD_T * TOXOVD_i * 5.0e8;

        // Self Heating parameters
        `ifdef SelfHeating
            RTH_T        =  RTH_i * pow(rTa, STRTH_i);
        `endif // SelfHeating

        // Noise model parameters
        fac_exc      = `MELE * 1.0e9 * FNTEXC_i;

        //ngspice-adms: Parasitic resistances - no node collapse
        RG_i       = `CLIP_LOW(RG, 1.0e-3);
        RSE_i      = `CLIP_LOW(RSE, 1.0e-3);
        RDE_i      = `CLIP_LOW(RDE, 1.0e-3);
        RBULK_i    = `CLIP_LOW(RBULK, 1.0e-3);
        RJUNS_i    = `CLIP_LOW(RJUNS, 1.0e-3);
        RJUND_i    = `CLIP_LOW(RJUND, 1.0e-3);
        RWELL_i    = `CLIP_LOW(RWELL, 1.0e-3);

        // Conductance of parasitic resistance
        if (RG_i > 0.0) begin
            ggate        =  1.0 / RG_i;
        end else begin
            ggate        =  0.0;
        end
        if (RSE_i > 0.0) begin
            gsource      =  1.0 / RSE_i;
        end else begin
            gsource      =  0.0;
        end
        if (RDE_i > 0.0) begin
            gdrain       =  1.0 / RDE_i;
        end else begin
            gdrain       =  0.0;
        end
        if (RBULK_i > 0.0) begin
            gbulk        =  1.0 / RBULK_i;
        end else begin
            gbulk        =  0.0;
        end
        if (RJUNS_i > 0.0) begin
            gjuns        =  1.0 / RJUNS_i;
        end else begin
            gjuns        =  0.0;
        end
        if (RJUND_i > 0.0) begin
            gjund        =  1.0 / RJUND_i;
        end else begin
            gjund        =  0.0;
        end
        if (RWELL_i > 0.0) begin
            gwell        =  1.0 / RWELL_i;
        end else begin
            gwell        =  0.0;
        end

        // JUNCAP instance parameters
        ABS_i        =  0.0;
        LSS_i        =  0.0;
        LGS_i        =  0.0;
        ABD_i        =  0.0;
        LSD_i        =  0.0;
        LGD_i        =  0.0;
        jwcorr       =  0.0;
        jww          =  WE;
        if (SWGEO_i == 0) begin
            jww          = `CLIP_LOW(JW_i, `LG_cliplow);
        end
        if (SWJUNCAP_i == 3) begin
            jwcorr       =  1.0;
        end
        ABS_i        =  ABSOURCE_i * invNF;
        LSS_i        =  LSSOURCE_i * invNF;
        LGS_i        =  LGSOURCE_i * invNF;
        ABD_i        =  ABDRAIN_i * invNF;
        LSD_i        =  LSDRAIN_i * invNF;
        LGD_i        =  LGDRAIN_i * invNF;
        if ((SWJUNCAP_i == 2) || (SWJUNCAP_i == 3)) begin
            ABS_i        =  AS_i * invNF;
            LSS_i        =  PS_i * invNF - jwcorr * jww;
            LGS_i        =  jww;
            ABD_i        =  AD_i * invNF;
            LSD_i        =  PD_i * invNF - jwcorr * jww;
            LGD_i        =  jww;
        end
        if ((SWJUNCAP_i == 1) || (SWJUNCAP_i == 2) || (SWJUNCAP_i == 3)) begin
            ABSOURCE_i   = `CLIP_LOW(ABS_i, `AB_cliplow);
            LSSOURCE_i   = `CLIP_LOW(LSS_i, `LS_cliplow);
            LGSOURCE_i   = `CLIP_LOW(LGS_i, `LG_cliplow);
            ABDRAIN_i    = `CLIP_LOW(ABD_i, `AB_cliplow);
            LSDRAIN_i    = `CLIP_LOW(LSD_i, `LS_cliplow);
            LGDRAIN_i    = `CLIP_LOW(LGD_i, `LG_cliplow);
        end else begin
            ABSOURCE_i   =  0.0;
            LSSOURCE_i   =  0.0;
            LGSOURCE_i   =  0.0;
            ABDRAIN_i    =  0.0;
            LSDRAIN_i    =  0.0;
            LGDRAIN_i    =  0.0;
        end

        // Initialization of JUNCAP (global) variables; required for some verilog-A compilers
        vbimin_s     =  0.0;
        vbimin_d     =  0.0;
        vfmin_s      =  0.0;
        vfmin_d      =  0.0;
        vch_s        =  0.0;
        vch_d        =  0.0;
        vbbtlim_s    =  0.0;
        vbbtlim_d    =  0.0;
        VMAX_s       =  0.0;
        VMAX_d       =  0.0;
        exp_VMAX_over_phitd_s =  0.0;
        exp_VMAX_over_phitd_d =  0.0;
        ISATFOR1_s   =  0.0;
        ISATFOR1_d   =  0.0;
        MFOR1_s      =  1.0;
        MFOR1_d      =  1.0;
        ISATFOR2_s   =  0.0;
        ISATFOR2_d   =  0.0;
        MFOR2_s      =  1.0;
        MFOR2_d      =  1.0;
        ISATREV_s    =  0.0;
        ISATREV_d    =  0.0;
        MREV_s       =  1.0;
        MREV_d       =  1.0;
        m0flag_s     =  0.0;
        m0flag_d     =  0.0;
        xhighf1_s    =  0.0;
        xhighf1_d    =  0.0;
        expxhf1_s    =  0.0;
        expxhf1_d    =  0.0;
        xhighf2_s    =  0.0;
        xhighf2_d    =  0.0;
        expxhf2_s    =  0.0;
        expxhf2_d    =  0.0;
        xhighr_s     =  0.0;
        xhighr_d     =  0.0;
        expxhr_s     =  0.0;
        expxhr_d     =  0.0;
        zflagbot_s   =  1.0;
        zflagbot_d   =  1.0;
        zflagsti_s   =  1.0;
        zflagsti_d   =  1.0;
        zflaggat_s   =  1.0;
        zflaggat_d   =  1.0;
        m0_rev       =  0.0;
        mcor_rev     =  0.0;
        I1_cor       =  0.0;
        I2_cor       =  0.0;
        I3_cor       =  0.0;
        I4_cor       =  0.0;
        I5_cor       =  0.0;
        tt0          =  0.0;
        tt1          =  0.0;
        tt2          =  0.0;
        zfrac        =  0.0;
        alphaje      =  0.0;

        if (SWJUNCAP_i > 0) begin
            `JuncapInitInstance(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, idsatbot,   idsatsti,   idsatgat,   vbibot,   vbisti,   vbigat,   PBOT_i,  PSTI_i,  PGAT_i,  VBIRBOT_i,  VBIRSTI_i,  VBIRGAT_i,  VMAX_s, exp_VMAX_over_phitd_s, vbimin_s, vch_s, vfmin_s, vbbtlim_s)
            `JuncapInitInstance(ABDRAIN_i,  LSDRAIN_i,  LGDRAIN_i,  idsatbot_d, idsatsti_d, idsatgat_d, vbibot_d, vbisti_d, vbigat_d, PBOTD_i, PSTID_i, PGATD_i, VBIRBOTD_i, VBIRSTID_i, VBIRGATD_i, VMAX_d, exp_VMAX_over_phitd_d, vbimin_d, vch_d, vfmin_d, vbbtlim_d)

            if (SWJUNEXP_i == 1) begin : JUNCAPexpressInit
                // Local variable declaration
//                `LocalGlobalVars

                // results computed here are not used elsewhere
//                real ijunbot, ijunsti, ijungat, qjunbot, qjunsti, qjungat;

                // Initialization of (local) variables; required for some verilog-A compilers
                ysq          =  0.0;
                terfc        =  0.0;
                erfcpos      =  0.0;
                h1           =  0.0;
                h2           =  0.0;
                h2d          =  0.0;
                h3           =  0.0;
                h4           =  0.0;
                h5           =  0.0;
                idmult       =  0.0;
                vj           =  0.0;
                z            =  0.0;
                zinv         =  0.0;
                two_psistar  =  0.0;
                vjlim        =  0.0;
                vjsrh        =  0.0;
                vbbt         =  0.0;
                vav          =  0.0;
                tmp          =  0.0;
                id           =  0.0;
                isrh         =  0.0;
                vbi_minus_vjsrh =  0.0;
                wsrhstep     =  0.0;
                dwsrh        =  0.0;
                wsrh         =  0.0;
                wdep         =  0.0;
                asrh         =  0.0;
                itat         =  0.0;
                btat         =  0.0;
                twoatatoverthreebtat =  0.0;
                umaxbeforelimiting =  0.0;
                umax         =  0.0;
                sqrtumax     =  0.0;
                umaxpoweronepointfive = 0.0;
                wgamma       =  0.0;
                wtat         =  0.0;
                ktat         =  0.0;
                ltat         =  0.0;
                mtat         =  0.0;
                xerfc        =  0.0;
                erfctimesexpmtat =  0.0;
                gammamax     =  0.0;
                ibbt         =  0.0;
                Fmaxr        =  0.0;
                fbreakdown   =  0.0;
                qjunbot      =  0.0;
                qjunsti      =  0.0;
                qjungat      =  0.0;

                // Computation of JUNCAP-express internal parameters
                `JuncapExpressInit1(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, VJUNREF_i, qprefbot, qpref2bot, vbiinvbot, one_minus_PBOT, idsatbot, CSRHBOT_i, CTATBOT_i, vbibot, wdepnulrbot, VBIRBOTinv, PBOT_i, ftdbot, btatpartbot, atatbot, one_over_one_minus_PBOT, CBBTBOT_i, VBIRBOT_i, wdepnulrinvbot, fbbtbot, VBRBOT_i, VBRinvbot, PBRBOT_i, fstopbot, slopebot, qprefsti, qpref2sti, vbiinvsti, one_minus_PSTI, idsatsti, CSRHSTI_i, CTATSTI_i, vbisti, wdepnulrsti, VBIRSTIinv, PSTI_i, ftdsti, btatpartsti, atatsti, one_over_one_minus_PSTI, CBBTSTI_i, VBIRSTI_i, wdepnulrinvsti, fbbtsti, VBRSTI_i, VBRinvsti, PBRSTI_i, fstopsti, slopesti, qprefgat, qpref2gat, vbiinvgat, one_minus_PGAT, idsatgat, CSRHGAT_i, CTATGAT_i, vbigat, wdepnulrgat, VBIRGATinv, PGAT_i, ftdgat, btatpartgat, atatgat, one_over_one_minus_PGAT, CBBTGAT_i, VBIRGAT_i, wdepnulrinvgat, fbbtgat, VBRGAT_i, VBRinvgat, PBRGAT_i, fstopgat, slopegat, VMAX_s, exp_VMAX_over_phitd_s, vbimin_s, vch_s, vfmin_s, vbbtlim_s)
                `JuncapExpressInit2(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, qprefbot, qpref2bot, vbiinvbot, one_minus_PBOT, idsatbot, CSRHBOT_i, CTATBOT_i, vbibot, wdepnulrbot, VBIRBOTinv, PBOT_i, ftdbot, btatpartbot, atatbot, one_over_one_minus_PBOT, CBBTBOT_i, VBIRBOT_i, wdepnulrinvbot, fbbtbot, VBRBOT_i, VBRinvbot, PBRBOT_i, fstopbot, slopebot, qprefsti, qpref2sti, vbiinvsti, one_minus_PSTI, idsatsti, CSRHSTI_i, CTATSTI_i, vbisti, wdepnulrsti, VBIRSTIinv, PSTI_i, ftdsti, btatpartsti, atatsti, one_over_one_minus_PSTI, CBBTSTI_i, VBIRSTI_i, wdepnulrinvsti, fbbtsti, VBRSTI_i, VBRinvsti, PBRSTI_i, fstopsti, slopesti, qprefgat, qpref2gat, vbiinvgat, one_minus_PGAT, idsatgat, CSRHGAT_i, CTATGAT_i, vbigat, wdepnulrgat, VBIRGATinv, PGAT_i, ftdgat, btatpartgat, atatgat, one_over_one_minus_PGAT, CBBTGAT_i, VBIRGAT_i, wdepnulrinvgat, fbbtgat, VBRGAT_i, VBRinvgat, PBRGAT_i, fstopgat, slopegat, VMAX_s, exp_VMAX_over_phitd_s, vbimin_s, vch_s, vfmin_s, vbbtlim_s)
                `JuncapExpressInit3(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, idsatbot, idsatsti, idsatgat, ISATFOR1_s, MFOR1_s, ISATFOR2_s, MFOR2_s, ISATREV_s, MREV_s, m0flag_s)
                `JuncapExpressInit4(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, FJUNQ_i, cjobot, cjosti, cjogat, zflagbot_s, zflagsti_s, zflaggat_s)
                `JuncapExpressInit5(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, ISATFOR1_s, ISATFOR2_s, ISATREV_s, xhighf1_s, expxhf1_s, xhighf2_s, expxhf2_s, xhighr_s, expxhr_s)

                `JuncapExpressInit1(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, VJUNREFD_i, qprefbot_d, qpref2bot_d, vbiinvbot_d, one_minus_PBOT_d, idsatbot_d, CSRHBOTD_i, CTATBOTD_i, vbibot_d, wdepnulrbot_d, VBIRBOTinv_d, PBOTD_i, ftdbot_d, btatpartbot_d, atatbot_d, one_over_one_minus_PBOT_d, CBBTBOTD_i, VBIRBOTD_i, wdepnulrinvbot_d, fbbtbot_d, VBRBOTD_i, VBRinvbot_d, PBRBOTD_i, fstopbot_d, slopebot_d, qprefsti_d, qpref2sti_d, vbiinvsti_d, one_minus_PSTI_d, idsatsti_d, CSRHSTID_i, CTATSTID_i, vbisti_d, wdepnulrsti_d, VBIRSTIinv_d, PSTID_i, ftdsti_d, btatpartsti_d, atatsti_d, one_over_one_minus_PSTI_d, CBBTSTID_i, VBIRSTID_i, wdepnulrinvsti_d, fbbtsti_d, VBRSTID_i, VBRinvsti_d, PBRSTID_i, fstopsti_d, slopesti_d, qprefgat_d, qpref2gat_d, vbiinvgat_d, one_minus_PGAT_d, idsatgat_d, CSRHGATD_i, CTATGATD_i, vbigat_d, wdepnulrgat_d, VBIRGATinv_d, PGATD_i, ftdgat_d, btatpartgat_d, atatgat_d, one_over_one_minus_PGAT_d, CBBTGATD_i, VBIRGATD_i, wdepnulrinvgat_d, fbbtgat_d, VBRGATD_i, VBRinvgat_d, PBRGATD_i, fstopgat_d, slopegat_d, VMAX_d, exp_VMAX_over_phitd_d, vbimin_d, vch_d, vfmin_d, vbbtlim_d)
                `JuncapExpressInit2(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, qprefbot_d, qpref2bot_d, vbiinvbot_d, one_minus_PBOT_d, idsatbot_d, CSRHBOTD_i, CTATBOTD_i, vbibot_d, wdepnulrbot_d, VBIRBOTinv_d, PBOTD_i, ftdbot_d, btatpartbot_d, atatbot_d, one_over_one_minus_PBOT_d, CBBTBOTD_i, VBIRBOTD_i, wdepnulrinvbot_d, fbbtbot_d, VBRBOTD_i, VBRinvbot_d, PBRBOTD_i, fstopbot_d, slopebot_d, qprefsti_d, qpref2sti_d, vbiinvsti_d, one_minus_PSTI_d, idsatsti_d, CSRHSTID_i, CTATSTID_i, vbisti_d, wdepnulrsti_d, VBIRSTIinv_d, PSTID_i, ftdsti_d, btatpartsti_d, atatsti_d, one_over_one_minus_PSTI_d, CBBTSTID_i, VBIRSTID_i, wdepnulrinvsti_d, fbbtsti_d, VBRSTID_i, VBRinvsti_d, PBRSTID_i, fstopsti_d, slopesti_d, qprefgat_d, qpref2gat_d, vbiinvgat_d, one_minus_PGAT_d, idsatgat_d, CSRHGATD_i, CTATGATD_i, vbigat_d, wdepnulrgat_d, VBIRGATinv_d, PGATD_i, ftdgat_d, btatpartgat_d, atatgat_d, one_over_one_minus_PGAT_d, CBBTGATD_i, VBIRGATD_i, wdepnulrinvgat_d, fbbtgat_d, VBRGATD_i, VBRinvgat_d, PBRGATD_i, fstopgat_d, slopegat_d, VMAX_d, exp_VMAX_over_phitd_d, vbimin_d, vch_d, vfmin_d, vbbtlim_d)
                `JuncapExpressInit3(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, idsatbot_d, idsatsti_d, idsatgat_d, ISATFOR1_d, MFOR1_d, ISATFOR2_d, MFOR2_d, ISATREV_d, MREV_d, m0flag_d)
                `JuncapExpressInit4(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, FJUNQD_i, cjobot_d, cjosti_d, cjogat_d, zflagbot_d, zflagsti_d, zflaggat_d)
                `JuncapExpressInit5(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, ISATFOR1_d, ISATFOR2_d, ISATREV_d, xhighf1_d, expxhf1_d, xhighf2_d, expxhf2_d, xhighr_d, expxhr_d)
            end // JUNCAPexpressInit

        end

    end // initial_instance

    begin : evaluateblock

//        real sigVds, dphit1, xgct, xsct0, xbct, xsbstar, xsct, dCTG, ct_fact, phit1, inv_phit1, xg_dc, alpha_dc, dps_dc, qim_dc;
//        real qim1_dc, H_dc, FdL_dc, Gvsatinv_dc, Ids, Iimpact, mavl, Igdov, Igsov, Igcd, Igcs, eta_p_ac, Gvsat_ac, Gmob_dL_ac, H0;
//        real COX_qm, ijun_s, ijunbot_s, ijunsti_s, ijungat_s, ijun_d, ijunbot_d, ijunsti_d, ijungat_d, qjun_s, qjunbot_s, qjunsti_s;
//        real qjungat_s, qjun_d, qjunbot_d, qjunsti_d, qjungat_d, jnoise_s, jnoise_d, Gmob_dc, xitsb_dc, Vdse_dc, Vsbstaredge, Vsbxedge;
//        real dphit1edge, phit1edge, inv_phit1edge, Vdspedge, delVgedge, xgedge, xbedge, dxthedge, xnedge_s, qseffedge, xnedge_d;
//        real qdseffedge, qdeffedge, qmeffedge, dsqredge, alphabmedge, Idsedge, Sfledge, midedge, sqidedge;
//        `ifdef SelfHeating
//            real Pdiss, phit, BET_i, BETEDGE_i, nt0, nt, THESAT_T, THESATAC_T, Sfl_prefac, phit0edge, Gfedge2, lnGfedge2, Sfl_prefac_edge;
//            real ntedge;
//        `endif // SelfHeating
//        real temp, temp1, temp2;

        //  --------------------------------------------------------------------------------------------------------------
        //  DC bias dependent quantities (calculations for current contribs)
        //  --------------------------------------------------------------------------------------------------------------
        begin : evaluateStatic

            // Initialize temporary variables
            temp        =  0.0;
            temp1       =  0.0;
            temp2       =  0.0;

            // Initialization of variables for SHE effect
            `ifdef SelfHeating
                TKD          =  TKA + Temp(br_rth);
                `TempInitialize
                `TempScaling
            `endif // SelfHeating
            QCLM         =  0.0;
            xs_ov        =  0.0;
            xd_ov        =  0.0;
            Vovs         =  0.0;
            Vovd         =  0.0;
            Iimpact      =  0.0;
            mavl         =  0.0;

            // Initialization of variables for NQS model
            `ifdef NQSmodel
                pd           =  1.0;
                ym           =  0.0;
            `endif // NQSmodel

            // Voltage affectations
            if (CHNL_TYPE == `NMOS) begin
                Vgs          =  V(GP, SI);
                Vds          =  V(DI, SI);
                Vsb          =  V(SI, BP);
                Vjun_s       = -V(SI, BS);
                Vjun_d       = -V(DI, BD);
            end else begin
                Vgs          = -V(GP, SI);
                Vds          = -V(DI, SI);
                Vsb          = -V(SI, BP);
                Vjun_s       =  V(SI, BS);
                Vjun_d       =  V(DI, BD);
            end
            Vgb          =  Vgs + Vsb;

            // Voltages NOT subject to S/D-interchange
            VgsPrime     =  Vgs;
            VsbPrime     =  Vsb;
            VdbPrime     =  Vds + Vsb;
            VgdPrime     =  Vgs - Vds;
            xgs_ov       = -VgsPrime * inv_phita;
            xgd_ov       = -VgdPrime * inv_phita;

            // Source-drain interchange
            sigVds       =  1.0;
            if (Vds < 0.0) begin
                sigVds       = -1.0;
                Vgs          =  Vgs - Vds;
                Vsb          =  Vsb + Vds;
                Vds          = -Vds;
            end
            Vdb          =  Vds + Vsb;
            Vdsx         =  Vds * Vds / (sqrt(Vds * Vds + 0.01) + 0.1);

            // Core's model calculation for DC
            begin : SPcalc_dc

                // Local variable declaration
//                `SPcalcLocalVarDecl
//                real FdL, qim1_1, r1, r2, s2, dL1;

                // Conditioning of terminal voltages
                temp         = `MINA(Vdb, Vsb, bphi_dc) + phix_dc;
                Vsbstar_dc   =  Vsb - `MINA(temp, 0, aphi_dc) + phix1_dc;
                Vsbstar_dc_tmp = Vsbstar_dc;

                // Adapt Vsb for NUD-effect
                if ((SWNUD_i != 0) && (GFACNUD_i != 1.0)) begin
                    Vmb          =  Vsbstar_dc + 0.5 * (Vds - Vdsx);
                    us           =  sqrt(Vmb + phib_dc) - sqrt_phib_dc;
                    temp         =  2.0 * (us - us1) / us21 - 1.0;
                    usnew        =  us - 0.25 * (1.0 - GFACNUD_i) * us21 * (temp + sqrt(temp * temp + 0.4804530139182));
                    Vmbnew       =  usnew * usnew + (2.0 * sqrt_phib_dc) * usnew;
                    Vsbstar_dc   =  Vmbnew - 0.5 * (Vds - Vdsx);
                end

                // Set variables needed in PSP_core macro
                phib         =  phib_dc;
                G_0          =  G_0_dc;
                Vsbstar      =  Vsbstar_dc;
                cfloc        =  CF_i;
                thesatloc    =  THESAT_T;
                axloc        =  AX_i;
                alploc       =  ALP_i;
                FdL          =  1.0;

                // Calculation of PSP model's core
                `SPCalculation

                if (xg > 0.0) begin
                    qim1_1       =  1.0 / qim1;
                    r1           =  qim * qim1_1;
                    r2           =  phit1 * (alpha * qim1_1);
                    s2           =  ln(1.0 + Vdsx * inv_VP);
                    dL1          =  dL + ALP1_i * (qim1_1 * r1 * s1) + ALP2_i * (qbm * r2 * r2 * s2);
                    FdL          =  (1.0 + dL1 + dL1 * dL1) * GdL;
                end

                xg_dc        =  xg;
                qeff1_dc     =  qeff1;
                Voxm_dc      =  Voxm;
                alpha_dc     =  alpha;
                dps_dc       =  dps;
                qim_dc       =  qim;
                qim1_dc      =  qim1;
                GdL_dc       =  GdL;
                FdL_dc       =  FdL;
                H_dc         =  H;
                eta_p_dc     =  eta_p;
                Gvsat_dc     =  Gvsat;
                Gvsatinv_dc  =  Gvsatinv;
                Gmob_dL_dc   =  Gmob_dL;
                x_ds_dc      =  x_ds;
                x_m_dc       =  x_m;
                Gf_dc        =  Gf;
                Vdsat_dc     =  Vdsat;
                Udse_dc      =  Udse;
                Gmob_dc      =  Gmob;
                xitsb_dc     =  xitsb;
                Vdse_dc      =  Vdse;
                `ifdef NQSmodel
                    xgm_dc       =  xgm;
                    thesat1_dc   =  thesat1;
                    margin_dc    =  margin;
                `endif // NQSmodel
            end // SPcalc_dc

            if (xg_dc <= 0) begin
                Ids          =  0.0;
            end else begin
                // Drain-source current
                Ids          =  BET_i * (FdL_dc * qim1_dc * dps_dc * Gvsatinv_dc);
            end

            // Surface potential in gate overlap regions
            if (((SWIGATE_i != 0) && ((IGOV_i > 0.0) || (IGOVD_i > 0.0))) || ((SWGIDL_i != 0) && ((AGIDL_i > 0.0) || (AGIDLD_i > 0.0))) || (CGOV_i > 0.0) || (CGOVD_i > 0.0)) begin
                SP_OV_xg     = 0.5 * (xgs_ov + sqrt(xgs_ov * xgs_ov + SP_OV_eps2_s));
                xs_ov        = -SP_OV_xg - GOV2_s * 0.5 + GOV_s * sqrt(SP_OV_xg + GOV2_s * 0.25 + SP_OV_a_s) + SP_OV_delta1_s;
                SP_OV_xg     = 0.5 * (xgd_ov + sqrt(xgd_ov * xgd_ov + SP_OV_eps2_d));
                xd_ov        = -SP_OV_xg - GOV2_d * 0.5 + GOV_d * sqrt(SP_OV_xg + GOV2_d * 0.25 + SP_OV_a_d) + SP_OV_delta1_d;
                Vovs         = -phita * (xgs_ov + xs_ov);
                Vovd         = -phita * (xgd_ov + xd_ov);
            end

            // Gate current
            Igsov        =  0.0;
            Igdov        =  0.0;
            Igc          =  0.0;
            Igb          =  0.0;
            Igcs         =  0.0;
            Igcd         =  0.0;
            if (SWIGATE_i != 0) begin
                if (IGOV_i > 0.0) begin
                    // Gate-source overlap component of gate current
                    zg           =  sqrt(Vovs * Vovs + 1.0e-6) * inv_CHIB;
                    if (GC3OV_i < 0.0) begin
                        zg           = `MINA(zg, GCQOV, 1.0e-6);
                    end
                    temp         =  BOV * (-1.5 + zg * (GC2OV_i + GC3OV_i * zg));
                    if (temp > 0.0) begin
                        TP           = `P3(temp);
                    end else begin
                        `expl_low(temp, TP)
                    end
                    Fs1          =  3.0 + xs_ov;
                    Fs2          = -3.0 - GCO_i;
                    Fs3          =  30.0 * VgsPrime;
                    `MNE(Fs1, Fs3, 0.9, temp)
                    `MXE(Fs2, temp, 0.3, Fs)
                    Igsov        =  IGOV_i * (TP * Fs);
                end

                if (IGOVD_i > 0.0) begin
                    // Gate-drain overlap component of gate current
                    zg           =  sqrt(Vovd * Vovd + 1.0e-6) * inv_CHIB;
                    if (GC3OV_i < 0.0) begin
                        zg           = `MINA(zg, GCQOV, 1.0e-6);
                    end
                    temp         =  BOV_d * (-1.5 + zg * (GC2OV_i + GC3OV_i * zg));
                    if (temp > 0.0) begin
                        TP           = `P3(temp);
                    end else begin
                        `expl_low(temp, TP)
                    end
                    Fs1          =  3.0 + xd_ov;
                    Fs2          = -3.0 - GCO_i;
                    Fs3          =  30.0 * VgdPrime;
                    `MNE(Fs1, Fs3, 0.9, temp)
                    `MXE(Fs2, temp, 0.3, Fs)
                    Igdov        =  IGOVD_i * (TP * Fs);
                end

                // Gate-channel component of gate current
                if (IGINV_i > 0.0) begin
                    if (xg_dc <= 0.0) begin
                        temp         =  pow(Vds / Vdsat_lim, AX_i);
                        Udse_dc      =  Vds * pow(1.0 + temp, -inv_AX) * inv_phit1;
                    end
                    `expl_low(x_ds_dc-Udse_dc, temp)
                    Vm           =  Vsbstar_dc + phit1 * (0.5 * x_ds_dc - ln(0.5 * (1.0 + temp)));
                    Dch          =  GCO_i * phit1;
                    arg2mina     =  Voxm_dc + Dch;
                    psi_t        = `MINA(0.0, arg2mina, 0.01);
                    zg           =  sqrt(Voxm_dc * Voxm_dc + 1.0e-6) * inv_CHIB;
                    if (GC3_i < 0.0) begin
                        zg           = `MINA(zg, GCQ, 1.0e-06);
                    end
                    arg1         =  (x_m_dc + (psi_t - alpha_b - Vm) * inv_phit1);
                    `expl(arg1,Dsi)
                    arg1         = -(Vgs + Vsbstar_dc - Vm) * inv_phit1;
                    `expl(arg1,temp)
                    Dgate        =  Dsi * temp;
                    temp         =  BCH * (-1.5 + zg * (GC2_i + GC3_i * zg));
                    if (temp > 0) begin
                        TP           = `P3(temp);
                    end else begin
                        `expl_low(temp, TP)
                    end
                    Igc0         =  IGINV_i * (TP * ln((1.0 + Dsi) / (1.0 + Dgate)));

                    // Source/drain partitioning of gate-channel current
                    if ((xg_dc <= 0.0) || ((GC2_i == 0.0) && (GC3_i == 0.0))) begin
                        igc          =  1.0;
                        igcd_h       =  0.5;
                    end else begin
                        temp         =  GC2_i + 2.0 * GC3_i * zg;
                        u0           =  CHIB_i / (temp * BCH);
                        x            =  0.5 * (dps_dc / u0);
                        u0_div_H     =  u0 / H_dc;
                        Bg           =  u0_div_H * (1.0 - u0_div_H) * 0.5;
                        Ag           =  0.5 - 3.0 * Bg;
                        if (x < 1.0e-3) begin
                            xsq          =  x * x;
                            igc          =  1.0 + xsq * (`oneSixth + u0_div_H * `oneThird + `oneSixth * (xsq * (0.05 + 0.2 * u0_div_H)));
                            igcd_h       =  0.5 * igc - `oneSixth * (x * (1.0 + xsq * (0.4 * (Bg + 0.25) + 0.0285714285714 * (xsq * (0.125 + Bg)))));
                        end else begin
                            inv_x        =  1.0 / x;
                            `expl(x, ex)
                            inv_ex       =  1.0 / ex;
                            temp         =  ex - inv_ex;
                            temp2        =  ex + inv_ex;
                            igc          =  0.5 * ((1.0 - u0_div_H) * temp * inv_x + u0_div_H * temp2);
                            igcd_h       =  0.5 * (igc - temp * (Bg - Ag * inv_x * inv_x) - Ag * temp2 * inv_x);
                        end
                    end
                    Sg           =  0.5 * (1.0 + xg_dc / sqrt(xg_dc * xg_dc + 1.0e-6));
                    Igc          =  Igc0 * igc * Sg;
                    Igcd         =  Igc0 * igcd_h * Sg;
                    Igcs         =  Igc - Igcd;
                    Igb          =  Igc0 * igc * (1.0 - Sg);
                end // (IGINV >0)
            end // (SWIGATE != 0)

            // GIDL/GISL current
            Igidl        =  0.0;
            Igisl        =  0.0;
            if (SWGIDL_i != 0) begin
                // GIDL current computation
                if ((AGIDLD_i > 0) && (Vovd < 0)) begin
                    Vtovd        =  sqrt(Vovd * Vovd + CGIDLD_i * CGIDLD_i * (VdbPrime * VdbPrime) + 1.0e-6);
                    temp         = -BGIDLDs / Vtovd;
                    `expl_low(temp, temp2)
                    Igidl        = -AGIDLDs * (VdbPrime * Vovd * Vtovd * temp2);
                end

                // GISL current computation
                if ((AGIDL_i > 0) && (Vovs < 0)) begin
                    Vtovs        =  sqrt(Vovs * Vovs + CGIDL_i * CGIDL_i * (VsbPrime * VsbPrime) + 1.0e-6);
                    temp         = -BGIDLs / Vtovs;
                    `expl_low(temp, temp2)
                    Igisl        = -AGIDLs * (VsbPrime * Vovs * Vtovs * temp2);
                end
            end // (SWGIDL != 0)

            // Drain current of edge transistors: PSP 103.4
            xgedge       =  0.0;
            qdseffedge   =  0.0;
            qmeffedge    =  0.0;
            dsqredge     =  1.0e-40;
            alphabmedge  =  1.0;
            Idsedge      =  0.0;
            if ((SWEDGE_i != 0.0) && (BETNEDGE_i > 0)) begin
                temp         = `MINA(Vdb, Vsb, bphiedge) + phixedge;
                Vsbstaredge  =  Vsb - `MINA(temp, 0, aphiedge) + phix1edge;
                Vsbxedge     =  Vsbstaredge + 0.5 * (Vds - Vdsx);
                dphit1edge   =  PSCEEDGE_i * (1 + PSCEDEDGE_i * Vdsx)* (1.0 + PSCEBEDGE_i * Vsbxedge); // SCE on subthreshold slope
                phit1edge    =  phit0edge * (1.0 + dphit1edge);
                inv_phit1edge =  1.0 / phit1edge;
                Vdspedge     =  2.0 * Vdsx / (1.0 + sqrt(1.0 + CFDEDGE_i * Vdsx));
                delVgedge    =  CFEDGE_i * Vdspedge * (1 + CFBEDGE_i * Vsbxedge); // DIBL effect
                xgedge       =  inv_phit1edge * (Vgs + Vsbstaredge + delVgedge - VFBEDGE_T);
                xbedge       =  inv_phit1edge * phibedge;
                dxthedge     =  2.0 * ln(xbedge / Gfedge + sqrt(xbedge));
                xnedge_s     =  inv_phit1edge * Vsbstaredge;
                `qi_edge(qseffedge,xgedge,xnedge_s)
                xnedge_d     =  inv_phit1edge * (Vdse_dc + Vsbstaredge);
                if ((qseffedge < 1.0e-3) && (Vdse_dc < 1.0e-6)) begin
                    `expl_low((-xnedge_d + xnedge_s), temp)
                    qdseffedge   =  qseffedge * (temp - 1.0);
                    qdeffedge    =  qdseffedge + qseffedge;
                end else begin
                    `qi_edge(qdeffedge,xgedge,xnedge_d)
                    qdseffedge   =  qdeffedge - qseffedge;
                end
                qmeffedge    =  0.5 * (qdeffedge + qseffedge);
                dsqredge     =  max(xgedge - qmeffedge, 1.0e-40);
                alphabmedge  =  1.0 - 0.5 * Gfedge / sqrt(dsqredge + 0.25 * Gfedge2);
                Idsedge      = -BETEDGE_i * phit1edge * phit1edge * (alphabmedge * qmeffedge  + 1.0) * qdseffedge / Gmob_dc;
            end

            // Impact-Ionization
            if ((xg_dc > 0) && (SWIMPACT_i != 0)) begin
                delVsat      =  Vds - A3_i * dps_dc;
                if (delVsat > 0) begin
                    temp2        =  A2_T * ((1.0 + A4_i * (sqrt(phib_dc + Vsbstar_dc) - sqrt_phib_dc)) / (delVsat + 1.0e-30));
                    `expl(-temp2, temp)
                    mavl         =  A1_i * (delVsat * temp);
                    Iimpact      =  mavl * (Ids + Idsedge);
                end
            end

            // Threshold voltage calculation for .OP
            P_D          =  1.0 + 0.25 * (Gf_dc * kp);
            facvsb0      =  phib_dc + 2.0 * phit1;
            facvsb       =  Vsbstar_dc + facvsb0;
            vts_i        =  VFB_T + P_D * facvsb - Vsbstar_dc + Gf_dc * sqrt(phit1 * facvsb );
            vth_i        =  vts_i - delVg;

        end // evaluateStatic

        //  --------------------------------------------------------------------------------------------------------------
        //  AC bias dependent quantities (calculations for charge contribs)
        //  --------------------------------------------------------------------------------------------------------------
        begin : evaluateDynamic

            // Core's model calculation for AC
            begin : SPcalc_ac

                // Local variable declaration
//                `SPcalcLocalVarDecl

                // SP calculations
                if ((SWNUD_i == 1) || (SWDELVTAC_i != 0) || (SWQSAT_i == 1)) begin

                    Vsbstar      =  Vsbstar_dc_tmp;
                    phib         =  phib_dc;
                    G_0          =  G_0_dc;
                    cfloc        =  CF_i;
                    thesatloc    =  THESAT_T;
                    axloc        =  AX_i;
                    alploc       =  ALP_i;

                    if (SWDELVTAC_i != 0) begin
                        // Conditioning of terminal voltages
                        temp         = `MINA(Vdb, Vsb, bphi_ac) + phix_ac;
                        Vsbstar_ac   =  Vsb - `MINA(temp, 0.0, aphi_ac) + phix1_ac;
                        Vsbstar      =  Vsbstar_ac;
                        phib         =  phib_ac;
                        G_0          =  G_0_ac;
                    end

                    if (SWQSAT_i != 0) begin
                        cfloc        =  CFAC_i;
                        thesatloc    =  THESATAC_T;
                        axloc        =  AXAC_i;
                        alploc       =  ALPAC_i;
                    end

                    // Calculation of PSP model's core
                    `SPCalculation

                    xg_ac        =  xg;
                    qeff1_ac     =  qeff1;
                    Voxm_ac      =  Voxm;
                    alpha_ac     =  alpha;
                    dps_ac       =  dps;
                    qim_ac       =  qim;
                    GdL_ac       =  GdL;
                    H_ac         =  H;
                    eta_p_ac     =  eta_p;
                    Gvsat_ac     =  Gvsat;
                    Gmob_dL_ac   =  Gmob_dL;
                    `ifdef NQSmodel
                        Gf_ac        =  Gf;
                        x_m_ac       =  x_m;
                        xgm_ac       =  xgm;
                        thesat1_ac   =  thesat1;
                        margin_ac    =  margin;
                    `endif // NQSmodel
                end else begin
                    xg_ac        =  xg_dc;
                    qeff1_ac     =  qeff1_dc;
                    Voxm_ac      =  Voxm_dc;
                    alpha_ac     =  alpha_dc;
                    dps_ac       =  dps_dc;
                    qim_ac       =  qim_dc;
                    GdL_ac       =  GdL_dc;
                    H_ac         =  H_dc;
                    eta_p_ac     =  eta_p_dc;
                    Gvsat_ac     =  Gvsat_dc;
                    Gmob_dL_ac   =  Gmob_dL_dc;
                    `ifdef NQSmodel
                        Gf_ac        =  Gf_dc;
                        x_m_ac       =  x_m_dc;
                        xgm_ac       =  xgm_dc;
                        thesat1_ac   =  thesat1_dc;
                        margin_ac    =  margin_dc;
                    `endif // NQSmodel
                end
            end // SPcalc_ac

            // Quantum mechanical corrections
            COX_qm       =  COX_i;
            if (qq > 0.0) begin
                COX_qm       =  COX_i / (1.0 + qq * pow(qeff1_ac * qeff1_ac + qlim2, -1.0 * `oneSixth));
            end

            // Intrinsic charge model
            if (xg_ac <= 0.0) begin
                QG           =  Voxm_ac;
                QI           =  0.0;
                QD           =  0.0;
                QB           =  QG;
            end else begin
                Fj           =  0.5 * (dps_ac / H_ac);
                Fj2          =  Fj * Fj;
                QG           =  Voxm_ac + 0.5 * (eta_p_ac * dps_ac * (Fj * GdL_ac * `oneThird - 1.0 + GdL_ac));
                temp         =  alpha_ac * dps_ac * `oneSixth;
                if (SWQPART_i == 1) begin
                    QCLM         =  0.0;
                    QD           =  0.5 * GdL_ac * GdL_ac * (qim_ac - 3.0 * temp * (2.0 - Fj));
                end else begin
                    QCLM         =  (1.0 - GdL_ac) * (qim_ac - 0.5 * (alpha_ac * dps_ac));
                    QD           =  0.5 * (GdL_ac * GdL_ac * (qim_ac - temp * (1.0 - Fj - 0.2 * Fj2)) + QCLM * (1.0 + GdL_ac));
                end
                QI           =  GdL_ac * (qim_ac + temp * Fj) + QCLM;
                QB           =  QG - QI;
            end
            Qg           =  QG * COX_qm;
            Qd           = -QD * COX_qm;
            Qb           = -QB * COX_qm;

            // Extrinsic charge model
            Qgs_ov       =  CGOV_i * Vovs;
            Qgd_ov       =  CGOVD_i * Vovd;
            Qgb_ov       =  CGBOV_i * Vgb;

            // Outer fringe charge
            Qfgs         =  CFR_i * VgsPrime;
            Qfgd         =  CFRD_i * VgdPrime;

            // Variables for NQS model
            `ifdef NQSmodel
                Gp           =  0.0;
                Gp2          =  0.0;
                a_factrp     =  0.0;
                marginp      =  0.0;
                if (SWNQS_i != 0) begin
                    if (xg_ac <= 0.0) begin
                        ym           =  0.5;
                        pd           =  1.0;
                        Gp           =  Gf_ac;
                    end else begin
                        ym           =  0.5 * ( 1.0 + 0.25 * (dps_ac / H_ac));
                        pd           =  xgm_ac / (xg_ac - x_m_ac);
                        Gp           =  Gf_ac / pd;
                    end
                    Gp2          =  Gp * Gp;
                    a_factrp     =  1.0 + Gp * `invSqrt2;
                    marginp      =  1.0e-5 * a_factrp;
                end
            `endif // NQSmodel

        end // evaluateDynamic

        //  --------------------------------------------------------------------------------------------------------------
        //  JUNCAP2 contribs
        //  --------------------------------------------------------------------------------------------------------------
        begin : evaluateStaticDynamic
            ijun_s       =  0.0;
            ijunbot_s    =  0.0;
            ijunsti_s    =  0.0;
            ijungat_s    =  0.0;
            ijun_d       =  0.0;
            ijunbot_d    =  0.0;
            ijunsti_d    =  0.0;
            ijungat_d    =  0.0;
            qjun_s       =  0.0;
            qjunbot_s    =  0.0;
            qjunsti_s    =  0.0;
            qjungat_s    =  0.0;
            qjun_d       =  0.0;
            qjunbot_d    =  0.0;
            qjunsti_d    =  0.0;
            qjungat_d    =  0.0;
            if (SWJUNCAP_i > 0) begin
                if (SWJUNEXP_i == 1) begin
                    `JuncapExpressCurrent(Vjun_s, MFOR1_s, ISATFOR1_s, MFOR2_s, ISATFOR2_s, MREV_s, ISATREV_s, m0flag_s, xhighf1_s, expxhf1_s, xhighf2_s, expxhf2_s, xhighr_s, expxhr_s, ijun_s)
                    `JuncapExpressCurrent(Vjun_d, MFOR1_d, ISATFOR1_d, MFOR2_d, ISATFOR2_d, MREV_d, ISATREV_d, m0flag_d, xhighf1_d, expxhf1_d, xhighf2_d, expxhf2_d, xhighr_d, expxhr_d, ijun_d)
                    begin : evaluateDynamic
//                        real tmpv, vjv;
                        `JuncapExpressCharge(Vjun_s, ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, qprefbot,   qprefsti,   qprefgat,   qpref2bot,   qpref2sti,   qpref2gat,   vbiinvbot,   vbiinvsti,   vbiinvgat,   one_minus_PBOT,   one_minus_PSTI,   one_minus_PGAT,   vfmin_s, vch_s, zflagbot_s, zflagsti_s, zflaggat_s, qjunbot_s, qjunsti_s, qjungat_s)
                        `JuncapExpressCharge(Vjun_d, ABDRAIN_i,  LSDRAIN_i,  LGDRAIN_i,  qprefbot_d, qprefsti_d, qprefgat_d, qpref2bot_d, qpref2sti_d, qpref2gat_d, vbiinvbot_d, vbiinvsti_d, vbiinvgat_d, one_minus_PBOT_d, one_minus_PSTI_d, one_minus_PGAT_d, vfmin_d, vch_d, zflagbot_d, zflagsti_d, zflaggat_d, qjunbot_d, qjunsti_d, qjungat_d)
                    end
                end else begin
                    `juncapcommon(Vjun_s, ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, qprefbot, qpref2bot, vbiinvbot, one_minus_PBOT, idsatbot, CSRHBOT_i, CTATBOT_i, vbibot, wdepnulrbot, VBIRBOTinv, PBOT_i, ftdbot, btatpartbot, atatbot, one_over_one_minus_PBOT, CBBTBOT_i, VBIRBOT_i, wdepnulrinvbot, fbbtbot, VBRBOT_i, VBRinvbot, PBRBOT_i, fstopbot, slopebot, qprefsti, qpref2sti, vbiinvsti, one_minus_PSTI, idsatsti, CSRHSTI_i, CTATSTI_i, vbisti, wdepnulrsti, VBIRSTIinv, PSTI_i, ftdsti, btatpartsti, atatsti, one_over_one_minus_PSTI, CBBTSTI_i, VBIRSTI_i, wdepnulrinvsti, fbbtsti, VBRSTI_i, VBRinvsti, PBRSTI_i, fstopsti, slopesti, qprefgat, qpref2gat, vbiinvgat, one_minus_PGAT, idsatgat, CSRHGAT_i, CTATGAT_i, vbigat, wdepnulrgat, VBIRGATinv, PGAT_i, ftdgat, btatpartgat, atatgat, one_over_one_minus_PGAT, CBBTGAT_i, VBIRGAT_i, wdepnulrinvgat, fbbtgat, VBRGAT_i, VBRinvgat, PBRGAT_i, fstopgat, slopegat, VMAX_s, exp_VMAX_over_phitd_s, vbimin_s, vch_s, vfmin_s, vbbtlim_s, ijunbot_s, qjunbot_s, ijunsti_s, qjunsti_s, ijungat_s, qjungat_s)
                    ijun_s = ABSOURCE_i * ijunbot_s + LSSOURCE_i * ijunsti_s + LGSOURCE_i * ijungat_s;
                    `juncapcommon(Vjun_d, ABDRAIN_i,  LSDRAIN_i,  LGDRAIN_i,  qprefbot_d, qpref2bot_d, vbiinvbot_d, one_minus_PBOT_d, idsatbot_d, CSRHBOTD_i, CTATBOTD_i, vbibot_d, wdepnulrbot_d, VBIRBOTinv_d, PBOTD_i, ftdbot_d, btatpartbot_d, atatbot_d, one_over_one_minus_PBOT_d, CBBTBOTD_i, VBIRBOTD_i, wdepnulrinvbot_d, fbbtbot_d, VBRBOTD_i, VBRinvbot_d, PBRBOTD_i, fstopbot_d, slopebot_d, qprefsti_d, qpref2sti_d, vbiinvsti_d, one_minus_PSTI_d, idsatsti_d, CSRHSTID_i, CTATSTID_i, vbisti_d, wdepnulrsti_d, VBIRSTIinv_d, PSTID_i, ftdsti_d, btatpartsti_d, atatsti_d, one_over_one_minus_PSTI_d, CBBTSTID_i, VBIRSTID_i, wdepnulrinvsti_d, fbbtsti_d, VBRSTID_i, VBRinvsti_d, PBRSTID_i, fstopsti_d, slopesti_d, qprefgat_d, qpref2gat_d, vbiinvgat_d, one_minus_PGAT_d, idsatgat_d, CSRHGATD_i, CTATGATD_i, vbigat_d, wdepnulrgat_d, VBIRGATinv_d, PGATD_i, ftdgat_d, btatpartgat_d, atatgat_d, one_over_one_minus_PGAT_d, CBBTGATD_i, VBIRGATD_i, wdepnulrinvgat_d, fbbtgat_d, VBRGATD_i, VBRinvgat_d, PBRGATD_i, fstopgat_d, slopegat_d, VMAX_d, exp_VMAX_over_phitd_d, vbimin_d, vch_d, vfmin_d, vbbtlim_d, ijunbot_d, qjunbot_d, ijunsti_d, qjunsti_d, ijungat_d, qjungat_d)
                    ijun_d = ABDRAIN_i * ijunbot_d + LSDRAIN_i * ijunsti_d + LGDRAIN_i * ijungat_d;
                end
            end

            //  --------------------------------------------------------------------------------------------------------------
            //  NQS and parasitic resistance contribs
            //  --------------------------------------------------------------------------------------------------------------

            // Set initial conditions for NQS model
            `ifdef NQSmodel
                `include "PSP103_InitNQS.include"
            `endif // NQSmodel

            // Parasitic resistances (including noise)
            rgatenoise   =  nt0 * ggate;
            rsourcenoise =  nt0 * gsource;
            rdrainnoise  =  nt0 * gdrain;
            rbulknoise   =  nt0 * gbulk;
            rjunsnoise   =  nt0 * gjuns;
            rjundnoise   =  nt0 * gjund;
            rwellnoise   =  nt0 * gwell;

        end // evaluateStaticDynamic

        //  --------------------------------------------------------------------------------------------------------------
        //  Current contribs
        //  --------------------------------------------------------------------------------------------------------------
        begin : loadStatic

            // Convert back for NMOS-PMOS and Source-Drain interchange
            if (sigVds > 0.0) begin
                I(DI, BP)    <+  CHNL_TYPE * MULT_i * Iimpact;
                I(DI, SI)    <+  CHNL_TYPE * MULT_i * (Ids + Idsedge);
                I(GP, SI)    <+  CHNL_TYPE * MULT_i * Igcs;
                I(GP, DI)    <+  CHNL_TYPE * MULT_i * Igcd;
            end else begin
                I(SI, BP)    <+  CHNL_TYPE * MULT_i * Iimpact;
                I(SI, DI)    <+  CHNL_TYPE * MULT_i * (Ids + Idsedge);
                I(GP, DI)    <+  CHNL_TYPE * MULT_i * Igcs;
                I(GP, SI)    <+  CHNL_TYPE * MULT_i * Igcd;
            end
            I(GP, BP)    <+  CHNL_TYPE * MULT_i * Igb;
            I(GP, SI)    <+  CHNL_TYPE * MULT_i * Igsov;
            I(GP, DI)    <+  CHNL_TYPE * MULT_i * Igdov;
            I(SI, BP)    <+  CHNL_TYPE * MULT_i * Igisl;
            I(DI, BP)    <+  CHNL_TYPE * MULT_i * Igidl;
            I(BS, SI)    <+  CHNL_TYPE * MULT_i * ijun_s;
            I(BD, DI)    <+  CHNL_TYPE * MULT_i * ijun_d;

            //ngspice-adms: Parasitic resistances - no node collapse
            `NonCollapsableR(ggate,   RG_i,    rgatenoise,   G,  GP, "rgate")
            `NonCollapsableR(gsource, RSE_i,   rsourcenoise, S,  SI, "rsource")
            `NonCollapsableR(gdrain,  RDE_i,   rdrainnoise,  D,  DI, "rdrain")
            `NonCollapsableR(gbulk,   RBULK_i, rbulknoise,   BP, BI, "rbulk")
            `NonCollapsableR(gjuns,   RJUNS_i, rjunsnoise,   BS, BI, "rjuns")
            `NonCollapsableR(gjund,   RJUND_i, rjundnoise,   BD, BI, "rjund")
            `NonCollapsableR(gwell,   RWELL_i, rwellnoise,   B,  BI, "rwell")

            I(DI, SI)  <+  `GMIN * V(DI, SI);

        end // loadStatic

        //  --------------------------------------------------------------------------------------------------------------
        //  ddt() contribs from charges (Note: MULT is handled explicitly)
        //  --------------------------------------------------------------------------------------------------------------
        begin : loadStaticDynamic

            // Implementation of NQS charges
            `ifdef NQSmodel
                `include "PSP103_ChargesNQS.include"
            `endif // NQSmodel

            // Implementation of Self heating effect
            `ifdef SelfHeating
                begin : self_heating
//                    real Pdiss_s, Pdiss_d;
                    Pdiss        =  0.0;
                    Pdiss_s      =  0.0;
                    Pdiss_d      =  0.0;
                    if (RSE_i > 0.0) begin
                        Pdiss_s      =  gsource * V(S, SI) * V(S, SI);
                    end
                    if (RDE_i > 0.0) begin
                        Pdiss_d      =  gdrain * V(D, DI) * V(D, DI);
                    end
                    if (RTH_p > 1.0e-3) begin
                        Pdiss        =  ((Ids + Idsedge) * Vds + Iimpact * (Vds + Vsb) + Pdiss_s + Pdiss_d);
                    end
                    Pwr(br_ith)  <+ -MULT_i * Pdiss;
                    Pwr(br_rth)  <+  ddt(MULT_i * CTH_i * Temp(br_rth));
                    Pwr(br_rth)  <+  MULT_i * Temp(br_rth) / RTH_T;
                end // self_heating
            `endif // SelfHeating

        end // loadStaticDynamic

        begin : loadDynamic

            // Local variable
//            real temp;

            // Intrinsic MOSFET charges
            Qs           =  -(Qg + Qb + Qd);

            // Total outerFringe + overlap for gate-source and gate-drain.
            Qfgs         =  Qfgs + Qgs_ov;
            Qfgd         =  Qfgd + Qgd_ov;

            // JUNCAP2
            qjun_s       =  ABSOURCE_i * qjunbot_s + LSSOURCE_i * qjunsti_s + LGSOURCE_i * qjungat_s;
            qjun_d       =  ABDRAIN_i * qjunbot_d + LSDRAIN_i * qjunsti_d + LGDRAIN_i * qjungat_d;

            // Convert back (undo S-D interchange)
            if (sigVds < 0.0) begin
                temp         =  Qd;    // Qd <--> Qs
                Qd           =  Qs;
                Qs           =  temp;
            end

            I(GP, SI)    <+  ddt(CHNL_TYPE * MULT_i * Qg);
            I(BP, SI)    <+  ddt(CHNL_TYPE * MULT_i * Qb);
            I(DI, SI)    <+  ddt(CHNL_TYPE * MULT_i * Qd);
            I(GP, SI)    <+  ddt(CHNL_TYPE * MULT_i * Qfgs);
            I(GP, DI)    <+  ddt(CHNL_TYPE * MULT_i * Qfgd);
            I(GP, BP)    <+  ddt(CHNL_TYPE * MULT_i * Qgb_ov);
            I(BS, SI)    <+  ddt(CHNL_TYPE * MULT_i * qjun_s);
            I(BD, DI)    <+  ddt(CHNL_TYPE * MULT_i * qjun_d);

        end // loadDynamic

        //  --------------------------------------------------------------------------------------------------------------
        //  Noise
        //  --------------------------------------------------------------------------------------------------------------
        begin : noise

            // Noise variable calculation
            Sfl          =  0.0;
            Sidexc       =  0.0;
            mid          =  0.0;
            mig          =  1.0e-40;
            migid        =  0.0;
            c_igid       =  0.0;
            CGeff        =  COX_qm * eta_p_ac;
            sqid         =  0.0;
            sqig         =  0.0;
            Sfledge      =  0.0;
            midedge      =  0.0;
            sqidedge     =  0.0;

            // Channel noise contributions
            if ((xg_dc > 0.0) && (MULT_i > 0.0) && (BET_i > 0.0)) begin
                // Flicker noise
                N1           =  Cox_over_q * alpha_dc * phit;
                Nm1          =  Cox_over_q * qim1_dc;
                Delta_N1     =  Cox_over_q * alpha_dc * dps_dc;
                Sfl          =  (NFA_i - NFB_i * N1 + NFC_i * (N1 * N1)) * ln((Nm1 + 0.5 * Delta_N1) / (Nm1 - 0.5 * Delta_N1));
                Sfl          =  Sfl + (NFB_i + NFC_i * (Nm1 - 2.0 * N1)) * Delta_N1;
                Sfl          =  Sfl_prefac * Ids * Gvsatinv_dc * Sfl / N1;
                Sfl          = `CLIP_LOW(Sfl, 0.0);

                // Thermal channel noise
                H0           =  qim1_dc / alpha_dc;
                t1           =  qim_dc / qim1_dc;
                sqt2         =  0.5 * `oneSixth * (dps_dc / H0);
                t2           =  sqt2 * sqt2;
                r            =  H0 / H_dc - 1.0;
                lc           = `CLIP_LOW(1.0 - 12.0 * (r * t2), 1.0e-20);
                lcinv2       =  1.0 / (lc * lc);
                g_ideal      =  BET_i * (FdL_dc * qim1_dc * Gvsatinv_dc);
                mid          =  t1 + 12.0 * t2 - 24.0 * ((1.0 + t1) * t2 * r);
                mid          = `CLIP_LOW(mid, 1.0e-40);
                mid          =  g_ideal * lcinv2 * mid;
                if (FNTEXC_i > 0.0) begin
                    // recalculate Gvsat, excluding Gmob-effect
                    temp2_exc    =  qim_dc * xitsb_dc;
                    wsat_exc     =  100.0 * (temp2_exc / (100.0 + temp2_exc));
                    if (THESATG_i < 0) begin
                        temp_exc     = 1.0 / (1.0 - THESATG_i * wsat_exc);
                    end else begin
                        temp_exc     = 1.0 + THESATG_i * wsat_exc;
                    end
                    thesat1_exc  =  THESAT_T * (temp_exc / Gmob_dc);
                    zsat_exc     =  thesat1_exc * thesat1_exc * dps_dc * dps_dc;
                    if (CHNL_TYPE == `PMOS) begin
                        zsat_exc     =  zsat_exc / (1.0 + thesat1_exc * dps_dc);
                    end
                    Gvsat_exc    =  0.5 * (Gmob_dc * (1.0 + sqrt(1.0 + 2.0 * zsat_exc)));
                    gfac         =  Gmob_dc / (Gvsat_exc * lc);
                    Sidexc       =  fac_exc * Ids * Vdse_dc * gfac * gfac;
                    mid          =  mid + Sidexc / nt0;
                end
                sqid         =  sqrt(nt * mid);

                // Induced gate noise
                if ((SWIGN_i == 1) && (nt > 0.0)) begin
                    mig          =  t1 / 12.0 - t2 * (t1 + 0.2 - 12.0 * t2) - 1.6 * (t2 * (t1 + 1.0 - 12.0 * t2) * r);
                    mig          = `CLIP_LOW(mig, 1.0e-40);
                    mig          =  lcinv2 / g_ideal * mig;
                    migid0       =  lcinv2 * sqt2 * (1.0 - 12.0 * t2 - (t1 + 19.2 * t2 - 12.0 * (t1 * t2)) * r);
                    CGeff        =  Gvsat_ac * Gvsat_ac * COX_qm * eta_p_ac / (Gmob_dL_ac * Gmob_dL_ac);
                    if (FNTEXC_i > 0.0) begin
                        mig          =  mig + Sidexc * (1.0 + 12.0 * t2) / (12.0 * g_ideal * g_ideal * nt0);
                        migid0       =  migid0 - Sidexc * sqt2 * (1.0 + r) / (g_ideal * nt0);
                    end
                    sqig         =  sqrt(nt / mig);
                    if (sqid == 0) begin
                        c_igid       =  0.0;
                    end else begin
                        c_igid       =  migid0 * sqig / sqid; // = migid0 / sqrt(mig * mid);
                    end
                    c_igid       = `CLIP_BOTH(c_igid, 0.0, 1.0);
                    migid        =  c_igid * sqid / sqig;
                end
            end

            // Noise of gate leakage currents
            shot_igcsx   =  2.0 * `QELE * abs(Igcs);
            shot_igcdx   =  2.0 * `QELE * abs(Igcd);
            shot_igsov   =  2.0 * `QELE * abs(Igsov);
            shot_igdov   =  2.0 * `QELE * abs(Igdov);

            // Noise of impact ionization currents
            shot_iavl    =  2.0 * `QELE * ((mavl + 1) * abs(Iimpact));

            // Noise of junctions (JUNCAP2)
            jnoisex_s    =  2.0 * `QELE * abs(ijun_s);
            jnoisex_d    =  2.0 * `QELE * abs(ijun_d);
            if (sigVds > 0.0) begin
                shot_igs     =  shot_igcsx + shot_igsov;
                shot_igd     =  shot_igcdx + shot_igdov;
                jnoise_s     =  jnoisex_s;
                jnoise_d     =  jnoisex_d + shot_iavl;
            end else begin
                shot_igs     =  shot_igcdx + shot_igsov;
                shot_igd     =  shot_igcsx + shot_igdov;
                jnoise_s     =  jnoisex_s + shot_iavl;
                jnoise_d     =  jnoisex_d;
            end

            // Noise of edge transistors: PSP 103.4
            if ((SWEDGE_i != 0.0) && (BETNEDGE_i > 0) && (xgedge > 0)) begin
                // Flicker noise of edge transistor
                temp1        =  4.0 * dsqredge / Gfedge2;
                anoisedge    =  sqrt(temp1 + 1.0) / (sqrt(temp1 + 1.1) - 1.0);
                temp1        =  Cox_over_q * phit;
                N1edge       =  temp1 * anoisedge;
                Nm1edge      =  temp1 * (qmeffedge + anoisedge);
                Delta_N1edge = -temp1 * anoisedge * alphabmedge * qdseffedge;
                Sfledge      =  (NFAEDGE_i - (NFBEDGE_i - NFCEDGE_i * N1edge) * N1edge) * ln((Nm1edge + 0.5 * Delta_N1edge) / (Nm1edge - 0.5 * Delta_N1edge));
                Sfledge      =  Sfledge + (NFBEDGE_i + NFCEDGE_i * (Nm1edge - 2.0 * N1edge)) * Delta_N1edge;
                Sfledge      =  Sfl_prefac_edge * Idsedge * Gvsatinv_dc * Sfledge / N1edge;
                Sfledge      = `CLIP_LOW(Sfledge, 0.0);

                // Thermal channel noise of edge transistor
                H0edge       =  phit * (qmeffedge + anoisedge) / anoisedge;
                t1edge       =  phit1 / phit * qmeffedge / (qmeffedge + anoisedge);
                sqt2edge     = -0.5 * `oneSixth * phit * alphabmedge * qdseffedge / H0edge;
                t2edge       =  sqt2edge * sqt2edge;
                redge        =  0.0;
                temp1        =  alpha_dc * H_dc;
                if (temp1 > 1.0e-10) begin
                    redge        =  anoisedge * H0edge / temp1 - 1.0;
                end
                lcedge       = `CLIP_LOW(1.0 - 12.0 * (redge * t2edge), 1.0e-20);
                lcinv2edge   =  1.0 / (lcedge * lcedge);
                g_idealedge  =  BETEDGE_i * phit * (qmeffedge + anoisedge) * FdL_dc * Gvsatinv_dc;
                midedge      =  t1edge + 12.0 * t2edge - 24.0 * ((1.0 + t1edge) * t2edge * redge);
                midedge      = `CLIP_LOW(midedge, 1.0e-40);
                midedge      =  g_idealedge * lcinv2edge * midedge;
                sqidedge     =  sqrt(ntedge * midedge);
            end

            // Noise contributions
            I(NOII)      <+  white_noise((nt / mig), "igig");
            I(NOIR)      <+  V(NOIR) / mig;
            I(NOIC)      <+  ddt(CGeff * V(NOIC));
//ngspice-adms: can't handle specific noise contributions
//            I(GP,SI)     <+ -ddt(sqrt(MULT_i) * 0.5 * CGeff * V(NOIC));
//            I(GP,DI)     <+ -ddt(sqrt(MULT_i) * 0.5 * CGeff * V(NOIC));
//            I(DI,SI)     <+  sigVds * sqrt(MULT_i) * migid * I(NOII);
            I(DI,SI)     <+  white_noise(MULT_i * sqid * sqid * (1.0 - c_igid * c_igid), "idid");
            I(DI,SI)     <+  flicker_noise(MULT_i * Sfl, EF_i, "flicker");
            I(GP,SI)     <+  white_noise(MULT_i * shot_igs, "igs");
            I(GP,DI)     <+  white_noise(MULT_i * shot_igd, "igd");
            I(BS,SI)     <+  white_noise(MULT_i * jnoise_s, "ibs");
            I(BD,DI)     <+  white_noise(MULT_i * jnoise_d, "ibd");
            I(DI,SI)     <+  flicker_noise(MULT_i * Sfledge, EFEDGE_i, "flicker");
            I(DI,SI)     <+  white_noise(MULT_i * sqidedge * sqidedge, "ididedge");

        end // noise

        //  --------------------------------------------------------------------------------------------------------------
        //  Operating point info
        //  --------------------------------------------------------------------------------------------------------------
        begin : OPinfo

            // Auxiliary variables
            id_op        =  Ids + Idsedge + Iimpact - Igcd;
            is           = -Ids - Idsedge - Igcs;
            ig           =  Igcs + Igcd + Igsov + Igdov + Igb;
            ib           = -Iimpact - Igb - Igidl - Igisl;
            sig1k        =  2.0e3 * `PI * CGeff;
            sig1k        =  sig1k * sig1k * mig;

            //  Actual operation point output variables
            sdint        =  sigVds;
            ctype        =  CHNL_TYPE;
            if (sigVds < 0.0) begin
                ise          =  MULT_i * (is - Igdov + Igidl - ijun_d);
                ige          =  MULT_i * ig;
                ide          =  MULT_i * (id_op - Igsov + Igisl - ijun_s);
                ibe          =  MULT_i * (ib + ijun_s + ijun_d);
                ids          =  MULT_i * Ids;
                idb          =  MULT_i * (Iimpact + Igisl - ijun_s);
                isb          =  MULT_i * (Igidl - ijun_d);
                igs          =  MULT_i * (Igcs + Igdov);
                igd          =  MULT_i * (Igcd + Igsov);
                igb          =  MULT_i * Igb;
                idedge       =  MULT_i * Idsedge;
                igcs         =  MULT_i * Igcs;
                igcd         =  MULT_i * Igcd;
                iavl         =  MULT_i * Iimpact;
                igisl        =  MULT_i * Igidl;
                igidl        =  MULT_i * Igisl;
                if (SWJUNEXP_i == 1) begin
                    ijsbot       =  0.0;
                    ijsgat       =  0.0;
                    ijssti       =  0.0;
                    ijdbot       =  0.0;
                    ijdgat       =  0.0;
                    ijdsti       =  0.0;
                    idsatsbot    =  0.0;
                    idsatssti    =  0.0;
                    idsatsgat    =  0.0;
                    idsatsbotd   =  0.0;
                    idsatsstid   =  0.0;
                    idsatsgatd   =  0.0;
                end else begin
                    ijsbot       =  MULT_i * ABDRAIN_i * ijunbot_d;
                    ijsgat       =  MULT_i * LGDRAIN_i * ijungat_d;
                    ijssti       =  MULT_i * LSDRAIN_i * ijunsti_d;
                    ijdbot       =  MULT_i * ABSOURCE_i * ijunbot_s;
                    ijdgat       =  MULT_i * LGSOURCE_i * ijungat_s;
                    ijdsti       =  MULT_i * LSSOURCE_i * ijunsti_s;
                    idsatsbot    =  MULT_i * ABSOURCE_i * idsatbot;
                    idsatssti    =  MULT_i * LSSOURCE_i * idsatsti;
                    idsatsgat    =  MULT_i * LGSOURCE_i * idsatgat;
                    idsatsbotd   =  MULT_i * ABDRAIN_i * idsatbot_d;
                    idsatsstid   =  MULT_i * LSDRAIN_i * idsatsti_d;
                    idsatsgatd   =  MULT_i * LGDRAIN_i * idsatgat_d;
                end
                ijs          =  MULT_i * ijun_d;
                ijd          =  MULT_i * ijun_s;
                vds          =  Vds;
                vgs          =  Vgs;
                vsb          =  Vsb;
                vto          =  VFB_T + P_D * facvsb0 + Gf_dc * sqrt(phit1 * facvsb0);
                vts          =  vts_i;
                vth          =  vth_i;
                vgt          =  vgs - vth;
                vdss         =  Vdsat_dc;
                vsat         =  Vds - vdss;
                ids_i        =  Ids + Idsedge + Iimpact + Igisl - Igcd - Igsov - ijun_s; // Total drain-current
                `ifdef OPderiv
                    gm           =  CHNL_TYPE * MULT_i * ddx(ids_i, V(GP));
                    gmb          =  CHNL_TYPE * MULT_i * ddx(ids_i, V(BP));
                    gds          =  CHNL_TYPE * MULT_i * ddx(ids_i, V(SI));
                    gjs          =  MULT_i * ddx(ijun_d, V(BD));
                    gjd          =  MULT_i * ddx(ijun_s, V(BS));
                    css          =  CHNL_TYPE * MULT_i * ddx(Qd, V(DI));
                    csg          = -CHNL_TYPE * MULT_i * ddx(Qd, V(GP));
                    csb          = -CHNL_TYPE * MULT_i * ddx(Qd, V(BP));
                    csd          =  css - csg - csb;
                    cgs          = -CHNL_TYPE * MULT_i * ddx(Qg, V(DI));
                    cgg          =  CHNL_TYPE * MULT_i * ddx(Qg, V(GP));
                    cgb          = -CHNL_TYPE * MULT_i * ddx(Qg, V(BP));
                    cgd          =  cgg - cgs - cgb;
                    cds          = -CHNL_TYPE * MULT_i * ddx(Qs, V(DI));
                    cdg          = -CHNL_TYPE * MULT_i * ddx(Qs, V(GP));
                    cdb          = -CHNL_TYPE * MULT_i * ddx(Qs, V(BP));
                    cdd          =  cdg + cds + cdb;
                    cbs          = -CHNL_TYPE * MULT_i * ddx(Qb, V(DI));
                    cbg          = -CHNL_TYPE * MULT_i * ddx(Qb, V(GP));
                    cbb          =  CHNL_TYPE * MULT_i * ddx(Qb, V(BP));
                    cbd          =  cbb - cbs - cbg;
                    cgsol        =  CHNL_TYPE * MULT_i * ddx(Qfgd, V(GP));
                    cgdol        =  CHNL_TYPE * MULT_i * ddx(Qfgs, V(GP));
                    cjsbot       = -MULT_i * CHNL_TYPE * ABDRAIN_i * ddx(qjunbot_d, V(DI));
                    cjsgat       = -MULT_i * CHNL_TYPE * LGDRAIN_i * ddx(qjungat_d, V(DI));
                    cjssti       = -MULT_i * CHNL_TYPE * LSDRAIN_i * ddx(qjunsti_d, V(DI));
                    cjs          =  cjsbot + cjsgat + cjssti;
                    cjdbot       = -MULT_i * CHNL_TYPE * ABSOURCE_i * ddx(qjunbot_s, V(SI));
                    cjdgat       = -MULT_i * CHNL_TYPE * LGSOURCE_i * ddx(qjungat_s, V(SI));
                    cjdsti       = -MULT_i * CHNL_TYPE * LSSOURCE_i * ddx(qjunsti_s, V(SI));
                    cjd          =  cjdbot + cjdgat + cjdsti;
                `endif // OPderiv
            end else begin
                ise          =  MULT_i * (is - Igsov + Igisl - ijun_s);
                ige          =  MULT_i * ig;
                ide          =  MULT_i * (id_op - Igdov + Igidl - ijun_d);
                ibe          =  MULT_i * (ib + ijun_s + ijun_d);
                ids          =  MULT_i * Ids;
                idb          =  MULT_i * (Iimpact + Igidl - ijun_d);
                isb          =  MULT_i * (Igisl - ijun_s);
                igs          =  MULT_i * (Igcs + Igsov);
                igd          =  MULT_i * (Igcd + Igdov);
                igb          =  MULT_i * Igb;
                idedge       =  MULT_i * Idsedge;
                igcs         =  MULT_i * Igcs;
                igcd         =  MULT_i * Igcd;
                iavl         =  MULT_i * Iimpact;
                igisl        =  MULT_i * Igisl;
                igidl        =  MULT_i * Igidl;
                if (SWJUNEXP_i == 1) begin
                    ijsbot       =  0.0;
                    ijsgat       =  0.0;
                    ijssti       =  0.0;
                    ijdbot       =  0.0;
                    ijdgat       =  0.0;
                    ijdsti       =  0.0;
                    idsatsbot    =  0.0;
                    idsatssti    =  0.0;
                    idsatsgat    =  0.0;
                    idsatsbotd   =  0.0;
                    idsatsstid   =  0.0;
                    idsatsgatd   =  0.0;
                end else begin
                    ijsbot       =  MULT_i * ABSOURCE_i * ijunbot_s;
                    ijsgat       =  MULT_i * LGSOURCE_i * ijungat_s;
                    ijssti       =  MULT_i * LSSOURCE_i * ijunsti_s;
                    ijdbot       =  MULT_i * ABDRAIN_i * ijunbot_d;
                    ijdgat       =  MULT_i * LGDRAIN_i * ijungat_d;
                    ijdsti       =  MULT_i * LSDRAIN_i * ijunsti_d;
                    idsatsbot    =  MULT_i * ABSOURCE_i * idsatbot;
                    idsatssti    =  MULT_i * LSSOURCE_i * idsatsti;
                    idsatsgat    =  MULT_i * LGSOURCE_i * idsatgat;
                    idsatsbotd   =  MULT_i * ABDRAIN_i * idsatbot_d;
                    idsatsstid   =  MULT_i * LSDRAIN_i * idsatsti_d;
                    idsatsgatd   =  MULT_i * LGDRAIN_i * idsatgat_d;
                end
                ijs          =  MULT_i * ijun_s;
                ijd          =  MULT_i * ijun_d;
                vds          =  Vds;
                vgs          =  Vgs;
                vsb          =  Vsb;
                vto          =  VFB_T + P_D * facvsb0 + Gf_dc * sqrt(phit1 * facvsb0);
                vts          =  vts_i;
                vth          =  vth_i;
                vgt          =  vgs - vth;
                vdss         =  Vdsat_dc;
                vsat         =  Vds - vdss;
                ids_i        =  Ids + Idsedge + Iimpact + Igidl - Igcd - Igdov - ijun_d; // Total drain-current
                `ifdef OPderiv
                    gm           =  CHNL_TYPE * MULT_i * ddx(ids_i, V(GP));
                    gmb          =  CHNL_TYPE * MULT_i * ddx(ids_i, V(BP));
                    gds          =  CHNL_TYPE * MULT_i * ddx(ids_i, V(DI));
                    gjs          = -MULT_i * ddx(ijun_s, V(SI));
                    gjd          = -MULT_i * ddx(ijun_d, V(DI));
                    cdd          =  CHNL_TYPE * MULT_i * ddx(Qd, V(DI));
                    cdg          = -CHNL_TYPE * MULT_i * ddx(Qd, V(GP));
                    cdb          = -CHNL_TYPE * MULT_i * ddx(Qd, V(BP));
                    cds          =  cdd - cdg - cdb;
                    cgd          = -CHNL_TYPE * MULT_i * ddx(Qg, V(DI));
                    cgg          =  CHNL_TYPE * MULT_i * ddx(Qg, V(GP));
                    cgb          = -CHNL_TYPE * MULT_i * ddx(Qg, V(BP));
                    cgs          =  cgg - cgd - cgb;
                    csd          = -CHNL_TYPE * MULT_i * ddx(Qs, V(DI));
                    csg          = -CHNL_TYPE * MULT_i * ddx(Qs, V(GP));
                    csb          = -CHNL_TYPE * MULT_i * ddx(Qs, V(BP));
                    css          =  csg + csd + csb;
                    cbd          = -CHNL_TYPE * MULT_i * ddx(Qb, V(DI));
                    cbg          = -CHNL_TYPE * MULT_i * ddx(Qb, V(GP));
                    cbb          =  CHNL_TYPE * MULT_i * ddx(Qb, V(BP));
                    cbs          =  cbb - cbd - cbg;
                    cgsol        =  CHNL_TYPE * MULT_i * ddx(Qfgs, V(GP));
                    cgdol        =  CHNL_TYPE * MULT_i * ddx(Qfgd, V(GP));
                    cjsbot       = -MULT_i * CHNL_TYPE * ABSOURCE_i * ddx(qjunbot_s, V(SI));
                    cjsgat       = -MULT_i * CHNL_TYPE * LGSOURCE_i * ddx(qjungat_s, V(SI));
                    cjssti       = -MULT_i * CHNL_TYPE * LSSOURCE_i * ddx(qjunsti_s, V(SI));
                    cjs          =  cjsbot + cjsgat + cjssti;
                    cjdbot       = -MULT_i * CHNL_TYPE * ABDRAIN_i * ddx(qjunbot_d, V(DI));
                    cjdgat       = -MULT_i * CHNL_TYPE * LGDRAIN_i * ddx(qjungat_d, V(DI));
                    cjdsti       = -MULT_i * CHNL_TYPE * LSDRAIN_i * ddx(qjunsti_d, V(DI));
                    cjd          =  cjdbot + cjdgat + cjdsti;
                `endif // OPderiv
            end
            weff         =  WE;
            leff         =  LE;
            `ifdef OPderiv
                if (abs(gds) < 1.0e-18) begin
                    u            =  0.0;
                    rout         =  0.0;
                    vearly       =  0.0;
                end else begin
                    u            =  gm / gds;
                    rout         =  1.0 / gds;
                    vearly       =  ide / gds;
                end
                if (abs(vgt) < 1.0e-12) begin
                    beff         =  0.0;
                end else begin
                    beff         =  2.0 * abs(ide) / (vgt * vgt);
                end
                if (abs(cgg + cgsol + cgdol) < 1.0e-30) begin
                    fug          =  0.0;
                end else begin
                    fug          =  gm / (2.0 * `PI * (cgg + cgsol + cgdol));
                end
                rg_op            =  RG_i / MULT_i;
                sfl          =  MULT_i * Sfl;
                if (abs(gm) < 1.0e-18) begin
                    sqrtsff      =  0.0;
                    sqrtsfw      =  0.0;
                end else begin
                    sqrtsff      =  sqrt(MULT_i * Sfl / 1000.0) / gm;
                    sqrtsfw      =  sqrt(MULT_i) * sqid / gm;
                end
                sid          =  MULT_i * sqid * sqid;
                sig          =  MULT_i * nt * sig1k / (1.0 + sig1k * mig);
                cigid        =  c_igid;
                if (sid == 0.0) begin
                    fknee        =  0.0;
                end else begin
                    fknee        =  sfl / sid;
                end
                siavl        =  MULT_i * shot_iavl;
                if (sigVds < 0.0) begin
                    sigs         =  MULT_i * (shot_igcsx + shot_igdov);
                    sigd         =  MULT_i * (shot_igcdx + shot_igsov);
                    ssi          =  MULT_i * jnoisex_d;
                    sdi          =  MULT_i * jnoisex_s;
                end else begin
                    sigs         =  MULT_i * (shot_igcsx + shot_igsov);
                    sigd         =  MULT_i * (shot_igcdx + shot_igdov);
                    ssi          =  MULT_i * jnoisex_s;
                    sdi          =  MULT_i * jnoisex_d;
                end
                sfledge      =  MULT_i * Sfledge;
                sidedge      =  MULT_i * sqidedge;
            `endif // OPderiv

            lp_vfb       =  VFB_T;
            lp_stvfb     =  STVFB_i;
            lp_st2vfb    =  ST2VFB_i;
            lp_tox       =  TOX_i;
            lp_epsrox    =  EPSROX_i;
            lp_neff      =  NEFF_i;
            lp_facneffac =  FACNEFFAC_i;
            lp_gfacnud   =  GFACNUD_i;
            lp_vsbnud    =  VSBNUD_i;
            lp_dvsbnud   =  DVSBNUD_i;
            lp_vnsub     =  VNSUB_i;
            lp_nslp      =  NSLP_i;
            lp_dnsub     =  DNSUB_i;
            lp_dphib     =  DPHIB_i;
            lp_delvtac   =  DELVTAC_i;
            lp_np        =  NP_i;
            lp_toxov     =  TOXOV_i;
            lp_toxovd    =  TOXOVD_i;
            lp_nov       =  NOV_i;
            lp_novd      =  NOVD_i;
            lp_ct        =  CT_T;
            lp_ctg       =  CTG_T;
            lp_ctb       =  CTB_i;
            lp_stct      =  STCT_i;
            lp_cf        =  CF_i;
            lp_cfac      =  CFAC_i;
            lp_cfd       =  CFD_i;
            lp_cfb       =  CFB_i;
            lp_psce      =  PSCE_i;
            lp_psceb     =  PSCEB_i;
            lp_psced     =  PSCED_i;
            lp_betn      =  BETN_T;
            lp_stbet     =  STBET_i;
            lp_mue       =  MUE_T;
            lp_stmue     =  STMUE_i;
            lp_themu     =  THEMU_T;
            lp_stthemu   =  STTHEMU_i;
            lp_cs        =  CS_T;
            lp_stcs      =  STCS_i;
            lp_thecs     =  THECS_T;
            lp_stthecs   =  STTHECS_i;
            lp_xcor      =  XCOR_T;
            lp_stxcor    =  STXCOR_i;
            lp_feta      =  FETA_i;
            lp_rs        =  RS_T;
            lp_strs      =  STRS_i;
            lp_rsb       =  RSB_i;
            lp_rsg       =  RSG_i;
            lp_thesat    =  THESAT_T;
            lp_thesatac  =  THESATAC_T;
            lp_stthesat  =  STTHESAT_i;
            lp_thesatb   =  THESATB_i;
            lp_thesatg   =  THESATG_i;
            lp_ax        =  AX_i;
            lp_axac      =  AXAC_i;
            lp_alp       =  ALP_i;
            lp_alpac     =  ALPAC_i;
            lp_alp1      =  ALP1_i;
            lp_alp2      =  ALP2_i;
            lp_vp        =  VP_i;
            lp_a1        =  A1_i;
            lp_a2        =  A2_T;
            lp_sta2      =  STA2_i;
            lp_a3        =  A3_i;
            lp_a4        =  A4_i;
            lp_gco       =  GCO_i;
            lp_iginv     =  IGINV_i;
            lp_igov      =  IGOV_i;
            lp_igovd     =  IGOVD_i;
            lp_stig      =  STIG_i;
            lp_gc2       =  GC2_i;
            lp_gc3       =  GC3_i;
            lp_gc2ov     =  GC2OV_i;
            lp_gc3ov     =  GC3OV_i;
            lp_chib      =  CHIB_i;
            lp_agidl     =  AGIDL_i;
            lp_agidld    =  AGIDLD_i;
            lp_bgidl     =  BGIDL_T;
            lp_bgidld    =  BGIDLD_T;
            lp_stbgidl   =  STBGIDL_i;
            lp_stbgidld  =  STBGIDLD_i;
            lp_cgidl     =  CGIDL_i;
            lp_cgidld    =  CGIDLD_i;
            lp_cox       =  COX_i;
            lp_cgov      =  CGOV_i;
            lp_cgovd     =  CGOVD_i;
            lp_cgbov     =  CGBOV_i;
            lp_cfr       =  CFR_i;
            lp_cfrd      =  CFRD_i;
            lp_fnt       =  FNT_i;
            lp_fntexc    =  FNTEXC_i;
            lp_nfa       =  NFA_i;
            lp_nfb       =  NFB_i;
            lp_nfc       =  NFC_i;
            lp_ef        =  EF_i;
            lp_vfbedge   =  VFBEDGE_T;
            lp_stvfbedge =  STVFBEDGE_i;
            lp_dphibedge =  DPHIBEDGE_i;
            lp_neffedge  =  NEFFEDGE_i;
            lp_ctedge    =  CTEDGE_i;
            lp_betnedge  =  BETNEDGE_T;
            lp_stbetedge =  STBETEDGE_i;
            lp_psceedge  =  PSCEEDGE_i;
            lp_pscebedge =  PSCEBEDGE_i;
            lp_pscededge =  PSCEDEDGE_i;
            lp_cfedge    =  CFEDGE_i;
            lp_cfdedge   =  CFDEDGE_i;
            lp_cfbedge   =  CFBEDGE_i;
            lp_fntedge   =  FNTEDGE_i;
            lp_nfaedge   =  NFAEDGE_i;
            lp_nfbedge   =  NFBEDGE_i;
            lp_nfcedge   =  NFCEDGE_i;
            lp_efedge    =  EFEDGE_i;
            lp_rg        =  RG_i;
            lp_rse       =  RSE_i;
            lp_rde       =  RDE_i;
            lp_rbulk     =  RBULK_i;
            lp_rwell     =  RWELL_i;
            lp_rjuns     =  RJUNS_i;
            lp_rjund     =  RJUND_i;
            `ifdef SelfHeating
                lp_rth       =  RTH_i;
                lp_cth       =  CTH_i;
                lp_strth     =  STRTH_i;
                pdiss        =  MULT_i * Pdiss;
                dtsh         =  TKD - TKA;
            `endif // SelfHeating
            tk           =  TKD;
            cjosbot      =  MULT_i * ABSOURCE_i * cjobot;
            cjossti      =  MULT_i * LSSOURCE_i * cjosti;
            cjosgat      =  MULT_i * LGSOURCE_i * cjogat;
            vbisbot      =  vbibot;
            vbissti      =  vbisti;
            vbisgat      =  vbigat;
            cjosbotd     =  MULT_i * ABDRAIN_i * cjobot_d;
            cjosstid     =  MULT_i * LSDRAIN_i * cjosti_d;
            cjosgatd     =  MULT_i * LGDRAIN_i * cjogat_d;
            vbisbotd     =  vbibot_d;
            vbisstid     =  vbisti_d;
            vbisgatd     =  vbigat_d;
            `ifdef NQSmodel
                lp_munqs     =  MUNQS_i;
            `endif // NQSmodel

        end // OPinfo

    end // evaluateblock

end // analogBlock
